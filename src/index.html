<!DOCTYPE >
<html>
  <head>
    <style>
      @font-face {
        font-family: Inter;
        src: url(./inter_variable.ttf);
      }

      button {
        background: linear-gradient(to bottom, #e4e4e4, #f7f7f7);
        border-radius: 5px;
        border: 1px solid #000000;
      }

      #fileSelect {
        padding: 6px 12px 6px 12px;
      }

      * {
        box-sizing: border-box;
      }

      html {
        font-family: "Inter";
        height: 100dvh;
        margin: 0;
        padding-bottom: 1px;
      }

      body {
        margin: 0;
        height: 100dvh;
        display: grid;
        justify-content: center;
        align-items: center;
      }

      h1 {
        font-weight: 700;
        line-height: 1.2;
        font-size: 48px;
      }

      h2 {
        font-size: 24px;
        font-weight: 400;
      }

      #menu {
        text-align: center;
      }

      #alert {
        display: none;
        color: #bf0e0e;
      }

      #canvas {
        position: relative;
        pointer-events: none;
      }

      #title {
        display: flex;
        justify-content: space-between;
        height: 74px;
        padding-top: 24px;
        padding-bottom: 10px;
        position: sticky;
        top: 0;
        z-index: 1;
        background: white;
        font-size: 32px;
        align-items: center;
        transition:
          height 1s,
          font-size 1s,
          padding 1s;
      }

      #title.animate {
        padding: 0;
        height: 36px;
        font-size: 20px;
      }

      #fileName {
        font-size: inherit;
        margin: 0;
      }

      #viewer {
        height: 100%;
        max-height: 100dvh;
        /* height: 400px!important; */
        width: 100dvw;
        max-width: 1200px;
        padding: 0 20px;
        justify-content: start;
        overflow-y: scroll;
      }

      .line {
        display: flex;
        align-items: center;

        position: absolute;
      }

      .column {
        flex-shrink: 0;
        width: 24px;
        height: 100%;
        border-left: 1px solid #bfbfbf;
        display: inline-block;
        position: relative;
        left: 1px;
      }

      .line {
        height: 28px;
        max-height: 28px;
      }

      .key {
        width: 0px;
      }

      .key.object {
        width: auto;
        color: #4e9590;
        padding-right: 4px;
        font-weight: 400;
      }

      .value {
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .key.number {
        width: auto;
        color: #bfbfbf;
        padding-right: 4px;
        font-weight: 400;
      }

      #back {
        aspect-ratio: 1;
      }

      .value.object {
        color: #d557da;
      }

      .value.string {
        color: #e86767;
      }

      .value.boolean,
      .value.number {
        color: #3d64ff;
      }

      .value.symbol {
        color: #f2cab8;
        font-weight: 700;
      }
    </style>
  </head>

  <body>
    <section id="menu">
      <h1>JSON Tree Viewer</h1>
      <h2>
        Simple JSON Viewer that runs completely on-client. No data exchange
      </h2>
      <input
        type="file"
        id="fileInput"
        accept="application/JSON"
        style="display: none"
      />
      <button id="fileSelect" type="button">Load JSON</button>
      <p id="alert">Invalid file. Please load a valid JSON file.</p>
    </section>
    <section id="viewer" style="display: none">
      <div id="title" class="">
        <h1 id="filename"></h1>
        <button id="back">âœ–</button>
      </div>
      <div id="canvas"></div>
    </section>
    <script>
      const CHUNK_SIZE = 0x200000;
      // const CHUNK_SIZE = 0x100;
      const TOKEN_TYPES = {
        LEFT_BRACKET: Symbol(),
        RIGHT_BRACKET: Symbol(),
      };

      const STATES = {
        VALUE: Symbol("VALUE"),
        WHITESPACE_VALUE: Symbol("WHITESPACE_VALUE"),
        STRING: Symbol("STRING"),
        STRING_ESCAPING: Symbol("STRING_ESCAPING"),
        STRING_UNICODE_1: Symbol("STRING_UNICODE_1"),
        STRING_UNICODE_2: Symbol("STRING_UNICODE_2"),
        STRING_UNICODE_3: Symbol("STRING_UNICODE_3"),
        STRING_UNICODE_4: Symbol("STRING_UNICODE_4"),
        NUMBER_ZERO: Symbol("NUMBER_ZERO"),
        NUMBER_INTEGER: Symbol("NUMBER_INTEGER"),
        NUMBER_FRACTION: Symbol("NUMBER_FRACTION"),
        NUMBER_EXPONENTIAL_INIT: Symbol("NUMBER_EXPONENTIAL"),
        NUMBER_EXPONENTIAL: Symbol("NUMBER_EXPONENTIAL"),
        TRUE_T: Symbol("TRUE_T"),
        TRUE_R: Symbol("TRUE_R"),
        TRUE_U: Symbol("TRUE_U"),
        FALSE_F: Symbol("FALSE_F"),
        FALSE_A: Symbol("FALSE_A"),
        FALSE_L: Symbol("FALSE_L"),
        FALSE_S: Symbol("FALSE_S"),
        NULL_N: Symbol("NULL_N"),
        NULL_U: Symbol("NULL_U"),
        NULL_L: Symbol("NULL_L"),
        ARRAY: Symbol("ARRAY"),
        ARRAY_MORE: Symbol("ARRAY_MORE"),
        OBJECT_KEY: Symbol("OBJECT_KEY"),
        OBJECT_COLON: Symbol("OBJECT_COLON"),
        OBJECT_MORE: Symbol("OBJECT_MORE"),
      };

      // elements
      const back = document.getElementById("back");
      const menu = document.getElementById("menu");

      const title = document.getElementById("title");
      const fileName = document.getElementById("filename");
      const fileSelect = document.getElementById("fileSelect");
      const fileInput = document.getElementById("fileInput");
      const alert = document.getElementById("alert");

      const viewer = document.getElementById("viewer");
      const canvas = document.getElementById("canvas");

      // index
      let i = 0;

      let lineCounter;
      let virtualDom = null;
      let pads = [];
      let keys = [];
      let values = [];
      let linesShown = Math.floor(document.body.clientHeight / 28) + 10;

      let file;
      let filePageLength;

      let buffer = new ArrayBuffer(CHUNK_SIZE);
      let reader;

      // read + decode
      let decoder = new TextDecoder("utf-8");
      let done;
      let readPages;
      let input;

      let consumedValueIndex;
      let state;
      let char;

      let pointers;
      let pointer;

      let pointersLen;
      let token;

      let oldCounter;

      let padCounter;
      let key = 0;
      let keyMap;

      // html

      const baseLineElement = document.createElement("div");
      baseLineElement.classList.add("line");
      baseLineElement.innerHTML = `<span class="key"></span><span class="value"></span>`;

      const baseCol = document.createElement("span");
      baseCol.classList.add("column");

      // Large virtual scroller
      var th = 0; // total theorical height (len(rows) * rowHeight)
      var h = canvas.clientHeight; // virtual scroller scroll height
      var ph = h / 100; // virtual page height
      var n = Math.ceil(th / ph); // number of virtual pages
      var vp = viewer.clientHeight; // actual DOM viewer height
      var cj = (th - h) / (n - 1); // "jumpiness" coefficient

      var rh = 28; // row height

      fileSelect.onclick = (e) => {
        fileInput.value = null;
        fileInput.click();
      };

      function setLine(pad, key, value) {
        pads.push(pad);
        keys.push(key);
        values.push(value);
      }

      back.onclick = () => {
        menu.style.display = "block";
        viewer.style.display = "none";
        canvas.innerHTML = "";
      };

      function invalidateFile(char, i, message) {
        done = true;
        menu.style.display = "block";
        viewer.style.display = "none";
        alert.style.display = "block";
        canvas.innerHTML = "";
        if (message) {
          console.error(message, char, i);
        }
      }

      fileInput.onchange = async (e) => {
        // ensure alert is hidden
        alert.style.display = "none";

        performance.mark("fileRead");

        file = fileInput.files[0];
        reader = file.stream().getReader({ mode: "byob" });
        fileName.innerText = file.name;
        filePageLength = Math.ceil(file.size / CHUNK_SIZE);

        // read + decode
        done = false;
        readPages = 0;

        // parser
        pads = [];
        keys = [];
        values = [];

        stateStack = [STATES.VALUE];
        contextStack = [];
        currentContext = null;
        state = STATES.VALUE;
        padCounter = 0;
        keyMap = new Map();

        function stackReplace(newState) {
          stateStack.pop();
          stateStack.push(newState);
          state = newState;
        }

        function stackPush(newState) {
          stateStack.push(newState);
          state = newState;
        }

        function stackPop() {
          stateStack.pop();
          if (stateStack.length) {
            state = stateStack[stateStack.length - 1];
          } else {
            state = null;
          }
        }

        pointersLen = 0;
        oldCounter = 0;

        // html
        lineCounter = 0;
        virtualDom = document.createDocumentFragment();

        viewer.style.display = "block";
        menu.style.display = "none";

        parsedChars = 0;
        async function seek() {
          performance.mark("read");

          const result = await reader.read(new Uint8Array(buffer));

          buffer = result.value.buffer;

          performance.measure("read", "read");
          performance.mark("decode");
          input = decoder.decode(result.value);
          performance.measure("decode", "decode");

          // lexer+parser
          i = 0;
          let subStart;
          performance.mark("lexer_parser");
          consumedValueIndex = 0;
          let inputLen = input.length;

          scanner: while (i < inputLen && !done) {
            char = input[i];

            // console.log(stateStack);
            // console.log(char, state);

            switch (state) {
              case STATES.VALUE:
                switch (char) {
                  case '"':
                    stackReplace(STATES.STRING);
                    subStart = i + 1;
                    break;

                  // NUMBERS
                  case "0":
                    stackReplace(STATES.NUMBER_ZERO);
                    subStart = i;
                    break;
                  case "-":
                  case "1":
                  case "2":
                  case "3":
                  case "4":
                  case "5":
                  case "6":
                  case "7":
                  case "8":
                  case "9":
                    stackReplace(STATES.NUMBER_INTEGER);
                    subStart = i;
                    break;

                  // true
                  case "t":
                    stackReplace(STATES.TRUE_T);
                    break;

                  // false
                  case "f":
                    stackReplace(STATES.FALSE_F);
                    break;

                  // null
                  case "n":
                    stackReplace(STATES.NULL_N);
                    break;

                  // array
                  case "[":
                    if (currentContext?.type === "ARRAY") {
                      setLine(
                        padCounter,
                        currentContext.key,
                        TOKEN_TYPES.LEFT_BRACKET,
                      );
                    } else if (currentContext === null) {
                      setLine(padCounter, undefined, TOKEN_TYPES.LEFT_BRACKET);
                    } else {
                      values[pads.length - 1] = TOKEN_TYPES.LEFT_BRACKET;
                    }

                    padCounter++;
                    contextStack.push({ type: "ARRAY", key: 0 });
                    currentContext = contextStack[contextStack.length - 1];

                    stackReplace(STATES.ARRAY);
                    break;

                  // object
                  case "{":
                    if (currentContext?.type === "ARRAY") {
                      setLine(padCounter, currentContext.key, undefined);
                      currentContext.key++;
                    } else if (currentContext === null) {
                      padCounter--;
                    }

                    contextStack.push({ type: "OBJECT", key: null });
                    padCounter++;
                    currentContext = contextStack[contextStack.length - 1];

                    stackReplace(STATES.OBJECT_KEY);
                    break;

                  default:
                    invalidateFile(char, i);
                    break scanner;
                }
                break;

              case STATES.STRING:
                switch (char) {
                  case '"':
                    let str = input.substring(subStart, i);

                    if (
                      stateStack[stateStack.length - 2] === STATES.OBJECT_COLON
                    ) {
                      key = keyMap.get(str);
                      if (!key) {
                        key = new String(str);
                        keyMap.set(str, key);
                      }
                      currentContext.key = key;
                      setLine(padCounter, currentContext.key, undefined);
                    } else {
                      if (currentContext?.type === "ARRAY") {
                        setLine(padCounter, currentContext.key, undefined);
                        currentContext.key++;
                      }

                      ind = pads.length - 1;
                      values[ind] = str;
                    }
                    stackPop();
                    // STRING FOUND
                    break;
                  case "\\":
                    stackReplace(STATES.STRING_ESCAPING);
                    break;
                }
                break;

              case STATES.STRING_ESCAPING:
                switch (char) {
                  // JSON SPEC
                  // case '"':
                  // case '\\':
                  // case '/':
                  // case 'b':
                  // case 'f':
                  // case 'n':
                  // case 'r':
                  // case 't':
                  //   stackReplace(STATES.STRING);
                  //   break;
                  case "u":
                    stackReplace(STATES.STRING_UNICODE_1);
                    break;
                  default:
                    //JSON SPEC
                    // invalidateFile(char, i, "Escaping");
                    // break scanner;
                    // NON SPEC
                    stackReplace(STATES.STRING);

                    break;
                }
                break;

              case STATES.STRING_UNICODE_1:
                // is char hex?
                if (
                  (char >= "0" && char <= "9") ||
                  (char >= "a" && char <= "f") ||
                  (char >= "A" && char <= "F")
                ) {
                  stackReplace(STATES.STRING_UNICODE_2);
                } else {
                  invalidateFile(c, i);
                  break scanner;
                }
                break;

              case STATES.STRING_UNICODE_2:
                // is char hex?
                if (
                  (char >= "0" && char <= "9") ||
                  (char >= "a" && char <= "f") ||
                  (char >= "A" && char <= "F")
                ) {
                  stackReplace(STATES.STRING_UNICODE_3);
                } else {
                  invalidateFile(c, i);
                  break scanner;
                }
                break;

              case STATES.STRING_UNICODE_3:
                // is char hex?
                if (
                  (char >= "0" && char <= "9") ||
                  (char >= "a" && char <= "f") ||
                  (char >= "A" && char <= "F")
                ) {
                  stackReplace(STATES.STRING_UNICODE_4);
                } else {
                  invalidateFile(c, i);
                  break scanner;
                }
                break;

              case STATES.STRING_UNICODE_4:
                // is char hex?
                if (
                  (char >= "0" && char <= "9") ||
                  (char >= "a" && char <= "f") ||
                  (char >= "A" && char <= "F")
                ) {
                  stackReplace(STATES.STRING);
                } else {
                  invalidateFile(c, i);
                  break scanner;
                }
                break;

              case STATES.NUMBER_ZERO:
                if (char === ".") {
                  stackReplace(STATES.NUMBER_FRACTION);
                } else if (char === "e" || char === "E") {
                  stackReplace(STATES.NUMBER_EXPONENTIAL_INIT);
                } else {
                  if (currentContext?.type === "ARRAY") {
                    setLine(padCounter, currentContext.key, undefined);
                    currentContext.key++;
                  }

                  ind = pads.length - 1;
                  values[ind] = +input.substring(subStart, i);
                  // Number Found
                  stackPop();
                  // backtrack
                  i--;
                }
                break;

              case STATES.NUMBER_INTEGER:
                if (char === ".") {
                  stackReplace(STATES.NUMBER_FRACTION);
                } else if (char === "e" || char === "E") {
                  stackReplace(STATES.NUMBER_EXPONENTIAL_INIT);
                } else if (char < "0" || char > "9") {
                  if (currentContext?.type === "ARRAY") {
                    setLine(padCounter, currentContext.key, undefined);
                    currentContext.key++;
                  }

                  ind = pads.length - 1;
                  values[ind] = +input.substring(subStart, i);
                  // Number Found
                  stackPop();
                  // backtrack
                  i--;
                }
                break;

              case STATES.NUMBER_FRACTION:
                if (char === "e" || char === "E") {
                  stackReplace(STATES.NUMBER_EXPONENTIAL_INIT);
                } else if (char < "0" || char > "9") {
                  if (currentContext?.type === "ARRAY") {
                    setLine(padCounter, currentContext.key, undefined);
                    currentContext.key++;
                  }

                  // console.log("sub", input.substring(subStart, i));
                  // console.log(pads, keys, values);
                  ind = pads.length - 1;
                  values[ind] = +input.substring(subStart, i);
                  // Number Found
                  stackPop();
                  // backtrack
                  i--;
                }
                break;

              case STATES.NUMBER_EXPONENTIAL_INIT:
                if (
                  char === "-" ||
                  char === "+" ||
                  char === "-" ||
                  (char >= "0" && char <= "9")
                ) {
                  stackReplace(STATES.NUMBER_EXPONENTIAL);
                } else {
                  invalidateFile(char, i);
                  break scanner;
                }
                break;

              case STATES.NUMBER_EXPONENTIAL:
                if (char < "0" || char > "9") {
                  if (currentContext?.type === "ARRAY") {
                    setLine(padCounter, currentContext.key, undefined);
                    currentContext.key++;
                  }

                  ind = pads.length - 1;
                  values[ind] = +input.substring(subStart, i);
                  // Number Found
                  stackPop();
                  // backtrack
                  i--;
                }
                break;

              case STATES.TRUE_T:
                if (char === "r") {
                  stackReplace(STATES.TRUE_R);
                } else {
                  invalidateFile(char, i);
                  break scanner;
                }
                break;

              case STATES.TRUE_R:
                if (char === "u") {
                  stackReplace(STATES.TRUE_U);
                } else {
                  invalidateFile(char, i);
                  break scanner;
                }
                break;

              case STATES.TRUE_U:
                if (char === "e") {
                  if (currentContext?.type === "ARRAY") {
                    setLine(padCounter, currentContext.key, undefined);
                    currentContext.key++;
                  }

                  ind = pads.length - 1;
                  values[ind] = true;
                  stackPop();
                } else {
                  invalidateFile(char, i);
                  break scanner;
                }
                break;

              case STATES.FALSE_F:
                if (char === "a") {
                  stackReplace(STATES.FALSE_A);
                } else {
                  invalidateFile(char, i);
                  break scanner;
                }
                break;

              case STATES.FALSE_A:
                if (char === "l") {
                  stackReplace(STATES.FALSE_L);
                } else {
                  invalidateFile(char, i);
                  break scanner;
                }
                break;

              case STATES.FALSE_L:
                if (char === "s") {
                  stackReplace(STATES.FALSE_S);
                } else {
                  invalidateFile(char, i);
                  break scanner;
                }
                break;

              case STATES.FALSE_S:
                if (char === "e") {
                  if (currentContext?.type === "ARRAY") {
                    setLine(padCounter, currentContext.key, undefined);
                    currentContext.key++;
                  }

                  ind = pads.length - 1;
                  values[ind] = false;
                  stackPop();
                } else {
                  invalidateFile(char, i);
                  break scanner;
                }
                break;

              case STATES.NULL_N:
                if (char === "u") {
                  stackReplace(STATES.NULL_U);
                } else {
                  invalidateFile(char, i);
                  break scanner;
                }
                break;

              case STATES.NULL_U:
                if (char === "l") {
                  stackReplace(STATES.NULL_L);
                } else {
                  invalidateFile(char, i);
                  break scanner;
                }
                break;

              case STATES.NULL_L:
                if (char === "l") {
                  if (currentContext?.type === "ARRAY") {
                    setLine(padCounter, currentContext.key, undefined);
                    currentContext.key++;
                  }

                  ind = pads.length - 1;
                  values[ind] = null;
                  stackPop();
                } else {
                  invalidateFile(char, i);
                  break scanner;
                }
                break;

              case STATES.ARRAY:
                if (char === "]") {
                  padCounter--;
                  contextStack.pop();
                  currentContext = contextStack[contextStack.length - 1];
                  setLine(padCounter, undefined, TOKEN_TYPES.RIGHT_BRACKET);
                  stackPop();
                } else if (
                  char === " " ||
                  char === "\t" ||
                  char === "\r" ||
                  char === "\n"
                ) {
                  // ignore whitespace
                } else {
                  stackPop();
                  stackPush(STATES.ARRAY_MORE);
                  stackPush(STATES.VALUE);
                  // backtrack
                  i--;
                }
                break;

              case STATES.ARRAY_MORE:
                if (char === "]") {
                  padCounter--;
                  contextStack.pop();
                  currentContext = contextStack[contextStack.length - 1];
                  setLine(padCounter, undefined, TOKEN_TYPES.RIGHT_BRACKET);
                  stackPop();
                } else if (
                  char === " " ||
                  char === "\t" ||
                  char === "\r" ||
                  char === "\n"
                ) {
                  // ignore whitespace
                } else if (char === ",") {
                  stackPop();
                  stackPush(STATES.ARRAY_MORE);
                  stackPush(STATES.WHITESPACE_VALUE);
                } else {
                  invalidateFile(char, i);
                  break scanner;
                }
                break;

              case STATES.OBJECT_KEY:
                if (char === "}") {
                  padCounter--;
                  contextStack.pop();
                  currentContext = contextStack[contextStack.length - 1];
                  stackPop();
                } else if (
                  char === " " ||
                  char === "\t" ||
                  char === "\r" ||
                  char === "\n"
                ) {
                  // ignore whitespace
                } else if (char === '"') {
                  subStart = i + 1;
                  stackPop();
                  stackPush(STATES.OBJECT_MORE);
                  stackPush(STATES.WHITESPACE_VALUE);
                  stackPush(STATES.OBJECT_COLON);
                  stackPush(STATES.STRING);
                } else {
                  invalidateFile(char, i);
                  break scanner;
                }
                break;

              case STATES.OBJECT_COLON:
                if (char === ":") {
                  stackPop();
                } else if (
                  char === " " ||
                  char === "\t" ||
                  char === "\r" ||
                  char === "\n"
                ) {
                  // ignore whitespace
                } else {
                  invalidateFile(char, i);
                  break scanner;
                }
                break;

              case STATES.OBJECT_MORE:
                if (char === "}") {
                  padCounter--;
                  contextStack.pop();
                  currentContext = contextStack[contextStack.length - 1];
                  stackPop();
                } else if (
                  char === " " ||
                  char === "\t" ||
                  char === "\r" ||
                  char === "\n"
                ) {
                  // ignore whitespace
                } else if (char === ",") {
                  stackPop();
                  stackPush(STATES.OBJECT_KEY);
                } else {
                  invalidateFile(char, i);
                  break scanner;
                }
                break;

              case STATES.WHITESPACE_VALUE:
                if (
                  char === " " ||
                  char === "\t" ||
                  char === "\r" ||
                  char === "\n"
                ) {
                  // ignore whitespace
                } else {
                  stackReplace(STATES.VALUE);
                  // backtrack
                  i--;
                }
                break;

              default:
                // unkown state
                if (
                  char === " " ||
                  char === "\t" ||
                  char === "\r" ||
                  char === "\n"
                ) {
                  // ignore whitespace
                } else {
                  invalidateFile();
                }
            }

            i++;
          }
          parsedChars += i;
          // console.log(parsedChars/file.size);

          if (parsedChars === file.size || result.done) {
            // console.log(pads, keys, values);
            done = true;
            performance.measure("fileRead", "fileRead");
          }

          if (done && stateStack.length) {
            invalidateFile(char, i);
          }

          performance.measure("lexer_parser", "lexer_parser");

          lineCounter = pads.length;
          oldCounter = lineCounter;

          // set height for virtual scroller
          th = lineCounter * rh + 74; // virtual height

          if (th < 1e7) {
            // just one page
            h = ph = th;
            n = 1;
            cj = 0;
          } else {
            // break into pages
            h = 1e7;
            ph = h / 100;
            n = Math.ceil(th / ph);
            cj = (th - h) / (n - 1);
          }

          vp = viewer.clientHeight;
          canvas.style.height = h;
        }
        // console.log(pads, keys, values);

        await seek();
        renderFreshCanvas();

        let deadline = performance.now() + 50;

        async function doWork() {
          if (!done) {
            await seek();
            if (
              navigator?.scheduling?.isInputPending() ||
              performance.now() >= deadline
            ) {
              await yieldToMain();
              deadline = performance.now() + 50;
            }
            doWork();
          }
        }

        await doWork();
      };

      // A function for shimming scheduler.yield and setTimeout:
      function yieldToMain() {
        // Use scheduler.yield if it exists:
        if ("scheduler" in window && "yield" in scheduler) {
          return scheduler.yield();
        }

        // Fall back to setTimeout:
        return new Promise((resolve) => {
          setTimeout(resolve, 0);
        });
      }

      window.addEventListener("resize", (event) => {
        linesShown = Math.floor(document.body.clientHeight / 28) + 10;

        vp = viewer.clientHeight; // viewer height

        renderFreshCanvas();
      });

      function renderFreshCanvas() {
        var y = viewer.scrollTop + virtualScrollOffset,
          buffer = vp,
          top = Math.floor((y - buffer) / rh),
          bottom = Math.ceil((y + vp + buffer) / rh);

        let start = Math.max(0, top);
        bottom = Math.min(th / rh, bottom);

        let diff = bottom - start;

        canvas.innerHTML = "";
        virtualDom = document.createDocumentFragment();
        for (i = 0; i <= diff; ++i) {
          let ind = pads.length - 1;
          if (i + start > ind) continue;

          const pad = pads[i + start];
          const key = keys[i + start];
          const value = values[i + start];

          const el = baseLineElement.cloneNode(true);

          // Padding
          for (var j = 0; j < pad; j++) {
            const col = baseCol.cloneNode();
            el.prepend(col);
          }

          // key
          if (typeof key !== "undefined") {
            let keyEl = el.querySelector(".key");
            keyEl.classList.add(typeof key);
            keyEl.innerText = `${key}:`;
          }

          // value
          let valueType = typeof value;
          if (valueType !== "undefined") {
            let valueEl = el.querySelector(".value");
            valueEl.classList.add(valueType);
            if (value === TOKEN_TYPES.LEFT_BRACKET) {
              valueEl.innerText = "[";
            } else if (value === TOKEN_TYPES.RIGHT_BRACKET) {
              valueEl.innerText = "]";
            } else if (valueType === "string") {
              valueEl.innerText = `"${String(value)}"`;
            } else {
              valueEl.innerText = String(value);
            }
          }

          el.style.top = (start + i) * rh - virtualScrollOffset;
          virtualDom.appendChild(el);
        }
        canvas.appendChild(virtualDom);
      }

      // Large virtual scroller
      var virtualScrollPage = 0; // current page
      var virtualScrollOffset = 0; // current page offset
      var prevScrollTop = 0;

      var content = canvas;

      // viewport.css("height", vp);
      // content.css("height", h);

      viewer.addEventListener("scroll", onScroll);

      function onScroll() {
        var scrollTop = viewer.scrollTop;

        // if (scrollTop > 0) {
        //   title.classList.add("animate");
        // } else {
        //   title.classList.remove("animate");
        // }

        if (Math.abs(scrollTop - prevScrollTop) > vp) {
          onJump();
        } else {
          onNearScroll();
        }

        renderFreshCanvas();
      }

      function onNearScroll() {
        var scrollTop = viewer.scrollTop;

        // next virtualScrollPage
        if (scrollTop + virtualScrollOffset > (virtualScrollPage + 1) * ph) {
          virtualScrollPage++;
          virtualScrollOffset = Math.round(virtualScrollPage * cj);
          viewer.scrollTop = prevScrollTop = scrollTop - cj;
        } else if (scrollTop + virtualScrollOffset < virtualScrollPage * ph) {
          // prev virtualScrollPage
          virtualScrollPage--;
          virtualScrollOffset = Math.round(virtualScrollPage * cj);
          viewer.scrollTop = prevScrollTop = scrollTop + cj;
        } else {
          prevScrollTop = scrollTop;
        }
      }

      function onJump() {
        var scrollTop = viewer.scrollTop;
        virtualScrollPage = Math.floor(
          scrollTop * ((th - vp) / (h - vp)) * (1 / ph),
        );
        virtualScrollOffset = Math.round(virtualScrollPage * cj);
        prevScrollTop = scrollTop;
      }
    </script>
  </body>
</html>
