<!DOCTYPE>
<html>

<head>
  <script src="purify.min.js"></script>
  <style>
    @font-face {
      font-family: Inter;
      src: url(./inter_variable.ttf);
    }

    * {
      box-sizing: border-box;
    }

    html {
      font-family: 'Inter';
      height: 100dvh;
      margin: 0;
      padding-bottom: 1px;
      overflow-y: scroll;
    }

    body {
      margin: 0;
      height: 100dvh;
      display: grid;
      justify-content: center;
      align-items: center;
    }

    h1 {
      font-weight: 700;
      line-height: 1.2;
    }

    h2 {
      font-size: 24px;
      font-weight: 400;
    }

    #menu {
      text-align: center;
    }

    #viewer h1 {
      font-size: 32px;
      padding-top: 24px;
      padding-bottom: 10px;
      margin: 0;
      height: 74px;
    }

    #viewer {
      height: 100%;
      width: 100dvw;
      max-width: 638px;
      display: flex;
      flex-direction: column;
      justify-content: start;
    }

    #canvas {
      /* border: 1px solid black; */
      /* flex: 1; */
      /* list-style-type: none; */
      /* counter-reset: css-counter 0; */
      position: relative;
    }

    .line {
      /* counter-increment: css-counter 1; */
      display: flex;
      align-items: center;
      position: absolute;
    }

    /* .line:before { */
    /*   width: 2rem; */
    /*   content: counter(css-counter) ". "; */
    /*   flex-shrink: 0; */
    /* } */

    .column {
      flex-shrink: 0;
      width: 24px;
      height: 100%;
      border-left: 1px solid #BFBFBF;
      display: inline-block;
      position: relative;
      left: 1px;
    }

    .line {
      height: 28px;
      max-height: 28px;
    }

    .string_key {
      color: #4E9590;
      padding-right: 4px;
      font-weight: 400;
    }

    .string,
    .boolean,
    .number {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .number_key {
      color: #BFBFBF;
      padding-right: 4px;
      font-weight: 400;
    }

    .bracket {
      color: #F2CAB8;
      font-weight: 700;
    }
  </style>
</head>

<body>
  <section id="menu">
    <h1>JSON Tree Viewer</h1>
    <h2>Simple JSON Viewer that runs completely on-client. No data exchange</h2>
    <input type="file" id="fileInput" accept="application/JSON" style="display:none" />
    <button id="fileSelect" type="button">Load JSON</button>
    <p style="color: #BF0E0E;display: none">Invalid file. Please load a valid JSON file.</p>
  </section>
  <section id="viewer" style="display: none">
    <h1 id="filename"></h1>
    <div id="canvas"></div>
  </section>
  <script type="module">
    import IntervalTree from '@flatten-js/interval-tree'

    const menu = document.querySelector('#menu');

    const fileName = document.querySelector('#filename');
    const fileSelect = document.querySelector('#fileSelect');
    const fileInput = document.querySelector('#fileInput');

    const viewer = document.querySelector('#viewer');
    const canvas = document.querySelector('#canvas');


    let intervalTree;
    let globalCounter;
    let virtualDom = null;

    fileSelect.onclick = (e) => {
      fileInput.click();
    }

    fileInput.onchange = async (e) => {
      // console.log('changed', fileInput.files[0]);
      let file = fileInput.files[0];
      fileName.innerText = file.name;

      let page = 0;
      let reader = new FileReader();
      // 0.5mb chunk
      let CHUNK_SIZE = Math.ceil(512 * 1024);
      let filePageLength = Math.ceil(file.size / CHUNK_SIZE);

      let tokens = [];
      let allDomPages = [];
      let value = '';
      let state = LEXER_STATES.NORMAL;
      intervalTree = new IntervalTree()
      globalCounter = 0;


      let currentToken = 0;
      let json = null;
      let parserState = PARSER_STATES.NORMAL;
      let pointers = [];
      pointers.push({obj: null, key: null, state: PARSER_STATES.NULL, isKey: false, count: 0});

      viewer.style.display = 'flex';
      menu.style.display = 'none';

      async function seek(start = 0, end = CHUNK_SIZE) {
        let blob = file.slice(start, end);
        let buffer = await blob.arrayBuffer();
        let data = new Uint8Array(buffer);
        let snippet = new TextDecoder('utf-8').decode(data);

        [value, state] = lexer(snippet, tokens, value, state);
        [currentToken, pointers] = parser(currentToken, tokens, pointers);
        page++;
        if (page >= filePageLength) {
          const pointer = pointers[0];
          const json = pointer.obj;
          console.log("LINES:", pointer.count);
          let startingPad = -1;
          if (Array.isArray(json)) {
            startingPad = 0;
          }

          const domPage = DOMPurify.sanitize(walkJsonObj(json, startingPad, '', true));
          virtualDom = document.createElement('div');
          virtualDom.innerHTML = domPage;
          // allDomPages.push(DomPage);
          // canvas.innerHTML = DomPage;
          canvas.style.height = `${pointer.count * 28}px`
          console.log(virtualDom);
          console.log(intervalTree.search([1, pointer.counter]));
          console.log(intervalTree.search([1, 3]));
        }
      }

      async function doWork() {
        // console.log('page', page, filePageLength, page / filePageLength);
        if (page < filePageLength) {
          await seek(page * CHUNK_SIZE, (page + 1) * CHUNK_SIZE);
          await yieldToMain();
          doWork();
        }
      }

      await doWork();
    }

    const walkJsonObj = (node, pad = 0, html = '', root = false) => {
      switch (typeof node) {
        case "object":
          if (node === null) {
            html += `<span class="null">null</span>`;
          } else if (!Array.isArray(node)) {
            pad++;
            html += `</div>`;
            for (let key in node) {
              let child = node[key];
              html += `<div class="line">${padLeft(pad)}<span class="string_key">${key}: </span>`;
              html += walkJsonObj(child, pad, '');
              html += '</div>'
            }
            pad--;
          } else {
            pad++;
            if (root) {
              html += '<div class="line"><span class="bracket">[</span></div>';
            } else {
              html += '<span class="bracket">[</span>';
            }
            html += `</div>`;
            for (let key = 0; key < node.length; key++) {
              let child = node[key];
              html += `<div class="line">${padLeft(pad)}<span class="number_key">${key}: </span>`;
              html += walkJsonObj(child, pad, '');
              html += '</div>'
            }
            pad--;
            html += `<div class="line">${padLeft(pad)}<span class="bracket">]</span></div>`;
          }
          break;
        case 'string':
          html += `<span class="string">"${node}"</span>`;
          break;
        case 'number':
          html += `<span class="number">${node}</span>`;
          break;
        case 'boolean':
          html += `<span class="boolean">${node}</span>`;
          break;
      }
      // console.log('OUT', node, html);
      return html;
    }

    function padLeft(pad) {
      if (pad < 0) return '';
      return new Array(pad).fill('<span class="column"></span>').join('');
    }

    // JSON tokenizer + parser
    // inspired by: https://dev.to/vit0rr/building-a-json-parser-from-scratch-with-js-3180
    // Adapted for rinha-frontend
    // Fixed tokenizer not recognizing floats
    // Fixed tokenizer not negative numbers 
    // Fixed tokenizer not recognizing escaping strings 
    // Lexer now consumes stream of chars (allowing to partially read json file)
    // Parser now consumes stream of tokens (allowing to partially read json file)
    const TOKEN_TYPES = {
      LEFT_BRACE: 'LEFT_BRACE',
      RIGHT_BRACE: 'RIGHT_BRACE',
      LEFT_BRACKET: 'LEFT_BRACKET',
      RIGHT_BRACKET: 'RIGHT_BRACKET',
      COLON: 'COLON',
      COMMA: 'COMMA',
      STRING: 'STRING',
      NUMBER: 'NUMBER',
      TRUE: 'TRUE',
      FALSE: 'FALSE',
      NULL: 'NULL',
    }

    const createToken = (type, value) => {
      return {
        type,
        value,
      }
    }

    const lexer = (input, tokens = [], value = '', state = LEXER_STATES.NORMAL) => {
      let current = 0;
      while (current < input.length) {
        let char = input[current]
        let parsed;

        [parsed, char, state, value, current] = parseChar(input, char, tokens, state, value, current);
        if (parsed) {
          current++;
          continue
        }

        console.error(char, state, value, current, tokens);
        throw new TypeError('I dont know what this character is: ' + char + ' c:' + current)
      }

      return [value, state];
    }

    const WHITESPACE = /\s/
    const SEPARATOR = /\./
    const NUMBER = /[0-9\.\-]/

    const LEXER_STATES = {
      NORMAL: 'NORMAL',
      NUMBER: 'NUMBER',
      STRING: 'STRING',
      TRUE_T: 'TRUE_T',
      TRUE_R: 'TRUE_R',
      TRUE_U: 'TRUE_U',
      TRUE_E: 'TRUE_E',
      FALSE_F: 'FALSE_F',
      FALSE_A: 'FALSE_A',
      FALSE_L: 'FALSE_L',
      FALSE_S: 'FALSE_S',
      FALSE_E: 'FALSE_E',
      NULL_N: 'NULL_N',
      NULL_U: 'NULL_U',
      NULL_L1: 'NULL_L1',
      NULL_L2: 'NULL_L2',
    }

    const parseChar = (input, char, tokens, state, value, current) => {
      let parsed = true;
      // console.log(char, state, value, tokens);
      if (state === LEXER_STATES.NUMBER) {
        if (NUMBER.test(char)) {
          value += char
        } else {
          tokens.push(createToken(TOKEN_TYPES.NUMBER, value))
          value = ''
          state = LEXER_STATES.NORMAL;
          // TODO: fix hack
          current--;
        }
      } else if (state === LEXER_STATES.STRING) {
        if (char !== '"') {
          if (char === '\\') {
            // TODO: fix hack
            value += char
            char = input[++current]
            value += char
          } else {
            value += char
          }
        } else {
          tokens.push(createToken(TOKEN_TYPES.STRING, value))
          value = ''
          state = LEXER_STATES.NORMAL
        }
      } else if (state === LEXER_STATES.TRUE_T) {
        if (char === 'r') {
          value += char;
          state = LEXER_STATES.TRUE_R
        } else {
          parsed = false;
        }
      } else if (state === LEXER_STATES.TRUE_R) {
        if (char === 'u') {
          value += char;
          state = LEXER_STATES.TRUE_U
        } else {
          parsed = false;
        }
      } else if (state === LEXER_STATES.TRUE_U) {
        if (char === 'e') {
          value += char;
          tokens.push(createToken(TOKEN_TYPES.TRUE))
          value = ''
          state = LEXER_STATES.NORMAL
        } else {
          parsed = false;
        }
      } else if (state === LEXER_STATES.FALSE_F) {
        if (char === 'a') {
          value += char;
          state = LEXER_STATES.FALSE_A
        } else {
          parsed = false;
        }
      } else if (state === LEXER_STATES.FALSE_A) {
        if (char === 'l') {
          value += char;
          state = LEXER_STATES.FALSE_L
        } else {
          parsed = false;
        }
      } else if (state === LEXER_STATES.FALSE_L) {
        if (char === 's') {
          value += char;
          state = LEXER_STATES.FALSE_S
        } else {
          parsed = false;
        }
      } else if (state === LEXER_STATES.FALSE_S) {
        if (char === 'e') {
          value += char;
          tokens.push(createToken(TOKEN_TYPES.FALSE))
          value = ''
          state = LEXER_STATES.NORMAL
        } else {
          parsed = false;
        }
      } else if (state === LEXER_STATES.NULL_N) {
        if (char === 'u') {
          value += char;
          state = LEXER_STATES.NULL_U
        } else {
          parsed = false;
        }
      } else if (state === LEXER_STATES.NULL_U) {
        if (char === 'l') {
          value += char;
          state = LEXER_STATES.NULL_L1
        } else {
          parsed = false;
        }
      } else if (state === LEXER_STATES.NULL_L1) {
        if (char === 'l') {
          value += char;
          tokens.push(createToken(TOKEN_TYPES.NULL))
          value = ''
          state = LEXER_STATES.NORMAL
        } else {
          parsed = false;
        }
      } else if (state === LEXER_STATES.NORMAL) {
        if (char === '{') {
          tokens.push(createToken(TOKEN_TYPES.LEFT_BRACE))
        } else if (char === '}') {
          tokens.push(createToken(TOKEN_TYPES.RIGHT_BRACE))
        } else if (char === '[') {
          tokens.push(createToken(TOKEN_TYPES.LEFT_BRACKET))
        } else if (char === ']') {
          tokens.push(createToken(TOKEN_TYPES.RIGHT_BRACKET))
        } else if (char === ':') {
          tokens.push(createToken(TOKEN_TYPES.COLON))
        } else if (char === ',') {
          tokens.push(createToken(TOKEN_TYPES.COMMA))
        } else if (WHITESPACE.test(char)) {
        } else if (NUMBER.test(char)) {
          state = LEXER_STATES.NUMBER
          value += char;
        } else if (char === '"') {
          state = LEXER_STATES.STRING
        } else if (char === 't') {
          state = LEXER_STATES.TRUE_T
          value += char;
        } else if (char === 'f') {
          state = LEXER_STATES.FALSE_F
          value += char;
        } else if (char === 'n') {
          state = LEXER_STATES.NULL_N
          value += char;
        } else {
          parsed = false;
        }
      }

      return [parsed, char, state, value, current];
    }

    const PARSER_STATES = {
      NULL: "NULL",
      NORMAL: "NORMAL",
      OBJECT: "OBJECT",
      ARRAY: "ARRAY",
    }

    const parser = (current, tokens, pointers = []) => {
      // console.log("PARSER", current, value, tokens, pointers);
      while (current < tokens.length) {
        const token = tokens[current];

        [parsed, current, pointers] = walk(current, token, pointers);
        if (parsed) {
          current++;
          continue
        }

        console.error(state, current, token, tokens);
        throw new TypeError(token.type)
      }

      return [current, pointers];
    }

    const setValue = (pointers, value) => {
      const pointer = pointers[pointers.length - 1];
      const {obj, key, state} = pointer;
      obj[key] = value;
      if (state === PARSER_STATES.ARRAY) {
        pointer.key++;
      } else {
        pointer.isKey = true;
      }
    }

    const sumCount = (pointers, count) => {
      const pointer = pointers[pointers.length - 1];
      pointer.count += count;
    }

    const walk = (current, token, pointers = []) => {
      let value;
      parsed = true;
      let pointer = pointers[pointers.length - 1];
      const {isKey, state} = pointer;

      if (token.type === TOKEN_TYPES.LEFT_BRACE) {
        if (state === PARSER_STATES.NULL) {
          pointer.obj = {};
          pointer.state = PARSER_STATES.OBJECT;
          pointer.isKey = true;
          pointer.key = null;
          pointer.count = 0;
        } else {
          pointers.push({obj: {}, key: null, state: PARSER_STATES.OBJECT, isKey: true, count: 0});
        }
        if (state === PARSER_STATES.ARRAY) {
          sumCount(pointers, 1);
          globalCounter += 1;
        }
      } else if (token.type === TOKEN_TYPES.RIGHT_BRACE) {
        if (pointers.length > 1) {
          let lastPointer = pointers.pop();
          value = lastPointer.obj;
          count = lastPointer.count;

          setValue(pointers, value);
          sumCount(pointers, count);
          // console.log([globalCounter - count, globalCounter], value)
          intervalTree.insert([globalCounter - count, globalCounter], value);
        } else {
          let lastPointer = pointers[0];
          value = lastPointer.obj;
          count = lastPointer.count;

          // console.log([globalCounter - count, globalCounter], value)
          intervalTree.insert([globalCounter - count, globalCounter], value);
        }
      } else if (token.type === TOKEN_TYPES.COMMA) {
        // DO NOTHING
      } else if (token.type === TOKEN_TYPES.COLON) {
        // DO NOTHING
      } else if (token.type === TOKEN_TYPES.LEFT_BRACKET) {
        if (state === PARSER_STATES.NULL) {
          pointer.obj = [];
          pointer.state = PARSER_STATES.ARRAY;
          pointer.isKey = false;
          pointer.key = 0;
          pointer.count = 2;
          globalCounter += 2;
        } else {
          pointers.push({obj: [], key: 0, state: PARSER_STATES.ARRAY, isKey: false, count: 1});
          globalCounter += 1;
        }
        if (state === PARSER_STATES.ARRAY) {
          sumCount(pointers, 1);
          globalCounter += 1;
        }
      } else if (token.type === TOKEN_TYPES.RIGHT_BRACKET) {
        if (pointers.length > 1) {
          let lastPointer = pointers.pop();
          value = lastPointer.obj;
          count = lastPointer.count;

          setValue(pointers, value);
          sumCount(pointers, count);
        }
      } else if (token.type === TOKEN_TYPES.STRING) {
        value = token.value;
        if (state === PARSER_STATES.OBJECT && isKey) {
          pointer.key = value;
          pointer.isKey = false;
          sumCount(pointers, 1);
          globalCounter += 1;
        } else {
          setValue(pointers, value);
          pointer.isKey = true;
        }

        if (state === PARSER_STATES.ARRAY) {
          sumCount(pointers, 1);
          globalCounter += 1;
        }
      } else if (token.type === TOKEN_TYPES.NUMBER) {
        setValue(pointers, +token.value);
        if (state === PARSER_STATES.ARRAY) {
          sumCount(pointers, 1);
          globalCounter += 1;
        }
      } else if (token.type === TOKEN_TYPES.TRUE) {
        setValue(pointers, true);
        if (state === PARSER_STATES.ARRAY) {
          sumCount(pointers, 1);
          globalCounter += 1;
        }
      } else if (token.type === TOKEN_TYPES.FALSE) {
        setValue(pointers, false);
        if (state === PARSER_STATES.ARRAY) {
          sumCount(pointers, 1);
          globalCounter += 1;
        }
      } else if (token.type === TOKEN_TYPES.NULL) {
        setValue(pointers, null);
        if (state === PARSER_STATES.ARRAY) {
          sumCount(pointers, 1);
          globalCounter += 1;
        }
      } else {
        parsed = false;
      }

      // console.log(current, "TOKEN:", token, pointers.map(p => p.count), pointers.map(p => p.count).reduce((acc, v) => acc+v, 0));
      return [parsed, current, pointers];
    }

    // A function for shimming scheduler.yield and setTimeout:
    function yieldToMain() {
      // Use scheduler.yield if it exists:
      if ('scheduler' in window && 'yield' in scheduler) {
        return scheduler.yield();
      }

      // Fall back to setTimeout:
      return new Promise(resolve => {
        setTimeout(resolve, 0);
      });
    }



    let currentLine = 0;
    function handleInfiniteScroll(evt) {
      const linesShown = Math.floor(document.body.offsetHeight / 28);
      let docH = document.body.scrollHeight - 74;
      let start = Math.max(0, Math.floor((window.scrollY - 74) / 28))
      let end = Math.floor((window.scrollY + - 74 + 28 * linesShown) / 28)

      canvas.innerHTML = '';
      for(let i =0; i <= linesShown; i++) {
        const el = virtualDom.children[i + start]?.cloneNode(true);
        console.log(el);
        if (!el) continue;
        // console.log(virtualDom.children);

        el.style.top = `${((i + start) * 28)}px`
        canvas.appendChild(el);
      }
      console.log(start, end);
    };

    window.addEventListener("scroll", handleInfiniteScroll);
    // handleInfiniteScroll();

  </script>
</body>

</html>
