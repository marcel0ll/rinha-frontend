<!DOCTYPE>
<html>

<head>
  <style>
    @font-face {
      font-family: Inter;
      src: url(./inter_variable.ttf);
    }

    * {
      box-sizing: border-box;
    }

    html {
      font-family: 'Inter';
      height: 100dvh;
      margin: 0;
      padding-bottom: 1px;
      overflow-y: scroll;
    }

    body {
      margin: 0;
      height: 100dvh;
      display: grid;
      justify-content: center;
      align-items: center;
    }

    h1 {
      font-weight: 700;
      line-height: 1.2;
    }

    h2 {
      font-size: 24px;
      font-weight: 400;
    }

    #menu {
      text-align: center;
    }

    #viewer h1 {
      font-size: 32px;
      padding-top: 24px;
      padding-bottom: 10px;
      margin: 0;
      height: 74px;
    }

    #viewer {
      height: 100%;
      width: 100dvw;
      max-width: 638px;
      display: flex;
      flex-direction: column;
      justify-content: start;
    }

    .line {
      display: flex;
      align-items: center;
    }

    .column {
      flex-shrink: 0;
      width: 24px;
      height: 100%;
      border-left: 1px solid #BFBFBF;
      display: inline-block;
      position: relative;
      left: 1px;
    }

    .line {
      height: 28px;
      max-height: 28px;
    }

    .key {
      width: 0px;
    }

    .key.string,
    .string_key {
      width: auto;
      color: #4E9590;
      padding-right: 4px;
      font-weight: 400;
    }

    .string,
    .boolean,
    .number {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }


    .key.number,
    .number_key {
      width: auto;
      color: #BFBFBF;
      padding-right: 4px;
      font-weight: 400;
    }

    .bracket {
      color: #F2CAB8;
      font-weight: 700;
    }
  </style>
</head>

<body>
  <section id="menu">
    <h1>JSON Tree Viewer</h1>
    <h2>Simple JSON Viewer that runs completely on-client. No data exchange</h2>
    <input type="file" id="fileInput" accept="application/JSON" style="display:none" />
    <button id="fileSelect" type="button">Load JSON</button>
    <p style="color: #BF0E0E;display: none">Invalid file. Please load a valid JSON file.</p>
  </section>
  <section id="viewer" style="display: none">
    <h1 id="filename"></h1>
    <div id="canvas"></div>
  </section>
  <script>
    const menu = document.querySelector('#menu');

    const fileName = document.querySelector('#filename');
    const fileSelect = document.querySelector('#fileSelect');
    const fileInput = document.querySelector('#fileInput');

    const viewer = document.querySelector('#viewer');
    const canvas = document.querySelector('#canvas');


    let globalCounter;
    let virtualDom = null;
    let allLines = [];
    let totalScrolled;
    let linesShown = Math.floor((document.body.offsetHeight - 74) / 28) - 1;

    const baseLineElement = document.createElement('div');
    baseLineElement.classList.add('line');
    baseLineElement.innerHTML = `<span class="key"></span><span class="value"></span>`;
    // console.log(baseLineElement);

    fileSelect.onclick = (e) => {
      fileInput.click();
    }

    fileInput.onchange = async (e) => {
      // console.log('changed', fileInput.files[0]);
      let file = fileInput.files[0];
      fileName.innerText = file.name;

      let page = 0;
      let reader = new FileReader();
      // 0.5mb chunk
      let CHUNK_SIZE = Math.ceil(10 * 512 * 1024);
      let data;
      let input;
      let filePageLength = Math.ceil(file.size / CHUNK_SIZE);

      let tokens = [];
      let allDomPages = [];
      let value = '';
      let state = LEXER_STATES.NORMAL;
      let char;
      let parsed;
      totalScrolled = 0;
      globalCounter = 0;
      virtualDom = document.createDocumentFragment();
      allLines = [];

      let current = 0;
      let currentToken = 0;
      let json = null;
      let parserState = PARSER_STATES.NORMAL;
      let pointers = [];
      let extraPad = 0;
      pointers.push({key: null, state: PARSER_STATES.NULL, isKey: false});

      viewer.style.display = 'flex';
      menu.style.display = 'none';

      async function seek(start = 0, end = CHUNK_SIZE) {
        let blob = file.slice(start, end);
        // arrayBuffer.set((await blob.arrayBuffer()));
        // uintArray.set(arrayBuffer);
        data = await blob.arrayBuffer();
        input = new TextDecoder('utf-8').decode(data);

        // lexer
        current = 0;
        parsed = true;
        while (current < input.length) {
          char = input[current]

          if (state === LEXER_STATES.NUMBER) {
            if (NUMBER.test(char)) {
              value += char
            } else {
              tokens.push({type: TOKEN_TYPES.NUMBER, value: value})
              value = ''
              state = LEXER_STATES.NORMAL;
              // TODO: fix hack
              current--;
            }
          } else if (state === LEXER_STATES.STRING) {
            if (char !== '"') {
              if (char === '\\') {
                // TODO: fix hack
                value += char
                char = input[++current]
                value += char
              } else {
                value += char
              }
            } else {
              tokens.push({type: TOKEN_TYPES.STRING, value: value})
              value = ''
              state = LEXER_STATES.NORMAL
            }
          } else if (state === LEXER_STATES.TRUE_T) {
            if (char === 'r') {
              value += char;
              state = LEXER_STATES.TRUE_R
            } else {
              parsed = false;
            }
          } else if (state === LEXER_STATES.TRUE_R) {
            if (char === 'u') {
              value += char;
              state = LEXER_STATES.TRUE_U
            } else {
              parsed = false;
            }
          } else if (state === LEXER_STATES.TRUE_U) {
            if (char === 'e') {
              value += char;
              tokens.push({type: TOKEN_TYPES.TRUE})
              value = ''
              state = LEXER_STATES.NORMAL
            } else {
              parsed = false;
            }
          } else if (state === LEXER_STATES.FALSE_F) {
            if (char === 'a') {
              value += char;
              state = LEXER_STATES.FALSE_A
            } else {
              parsed = false;
            }
          } else if (state === LEXER_STATES.FALSE_A) {
            if (char === 'l') {
              value += char;
              state = LEXER_STATES.FALSE_L
            } else {
              parsed = false;
            }
          } else if (state === LEXER_STATES.FALSE_L) {
            if (char === 's') {
              value += char;
              state = LEXER_STATES.FALSE_S
            } else {
              parsed = false;
            }
          } else if (state === LEXER_STATES.FALSE_S) {
            if (char === 'e') {
              value += char;
              tokens.push({type: TOKEN_TYPES.FALSE})
              value = ''
              state = LEXER_STATES.NORMAL
            } else {
              parsed = false;
            }
          } else if (state === LEXER_STATES.NULL_N) {
            if (char === 'u') {
              value += char;
              state = LEXER_STATES.NULL_U
            } else {
              parsed = false;
            }
          } else if (state === LEXER_STATES.NULL_U) {
            if (char === 'l') {
              value += char;
              state = LEXER_STATES.NULL_L1
            } else {
              parsed = false;
            }
          } else if (state === LEXER_STATES.NULL_L1) {
            if (char === 'l') {
              value += char;
              tokens.push({type: TOKEN_TYPES.NULL})
              value = ''
              state = LEXER_STATES.NORMAL
            } else {
              parsed = false;
            }
          } else if (state === LEXER_STATES.NORMAL) {
            if (char === '{') {
              tokens.push({type: TOKEN_TYPES.LEFT_BRACE})
            } else if (char === '}') {
              tokens.push({type: TOKEN_TYPES.RIGHT_BRACE})
            } else if (char === '[') {
              tokens.push({type: TOKEN_TYPES.LEFT_BRACKET})
            } else if (char === ']') {
              tokens.push({type: TOKEN_TYPES.RIGHT_BRACKET})
            } else if (char === ':') {
              tokens.push({type: TOKEN_TYPES.COLON})
            } else if (char === ',') {
              tokens.push({type: TOKEN_TYPES.COMMA})
            } else if (WHITESPACE.test(char)) {
            } else if (NUMBER.test(char)) {
              state = LEXER_STATES.NUMBER
              value += char;
            } else if (char === '"') {
              state = LEXER_STATES.STRING
            } else if (char === 't') {
              state = LEXER_STATES.TRUE_T
              value += char;
            } else if (char === 'f') {
              state = LEXER_STATES.FALSE_F
              value += char;
            } else if (char === 'n') {
              state = LEXER_STATES.NULL_N
              value += char;
            } else {
              parsed = false;
            }
          }
          if (parsed) {
            current++;
            continue
          } else {
            console.error(char, state, value, current, tokens);
            throw new TypeError('I dont know what this character is: ' + char + ' c:' + current)
          }
        }


        // parser
        [currentToken, pointers, extraPad] = parser(currentToken, tokens, pointers, extraPad);
        page++;
      }

      await seek(page * CHUNK_SIZE, (page + 1) * CHUNK_SIZE);
      renderCanvas();

      async function doWork() {
        // console.log('page', page, filePageLength, page / filePageLength);
        if (page < filePageLength) {
          await seek(page * CHUNK_SIZE, (page + 1) * CHUNK_SIZE);
          await yieldToMain();
          doWork();
        }
      }

      await doWork();
    }

    // JSON tokenizer + parser
    // inspired by: https://dev.to/vit0rr/building-a-json-parser-from-scratch-with-js-3180
    // Adapted for rinha-frontend
    // Fixed tokenizer not recognizing floats
    // Fixed tokenizer not negative numbers 
    // Fixed tokenizer not recognizing escaping strings 
    // Lexer now consumes stream of chars (allowing to partially read json file)
    // Parser now consumes stream of tokens (allowing to partially read json file)
    const TOKEN_TYPES = {
      LEFT_BRACE: 'LEFT_BRACE',
      RIGHT_BRACE: 'RIGHT_BRACE',
      LEFT_BRACKET: 'LEFT_BRACKET',
      RIGHT_BRACKET: 'RIGHT_BRACKET',
      COLON: 'COLON',
      COMMA: 'COMMA',
      STRING: 'STRING',
      NUMBER: 'NUMBER',
      TRUE: 'TRUE',
      FALSE: 'FALSE',
      NULL: 'NULL',
    }

    const WHITESPACE = /\s/
    const NUMBER = /[0-9\.\-]/

    const LEXER_STATES = {
      NORMAL: 'NORMAL',
      NUMBER: 'NUMBER',
      STRING: 'STRING',
      TRUE_T: 'TRUE_T',
      TRUE_R: 'TRUE_R',
      TRUE_U: 'TRUE_U',
      TRUE_E: 'TRUE_E',
      FALSE_F: 'FALSE_F',
      FALSE_A: 'FALSE_A',
      FALSE_L: 'FALSE_L',
      FALSE_S: 'FALSE_S',
      FALSE_E: 'FALSE_E',
      NULL_N: 'NULL_N',
      NULL_U: 'NULL_U',
      NULL_L1: 'NULL_L1',
      NULL_L2: 'NULL_L2',
    }

    const PARSER_STATES = {
      NULL: "NULL",
      NORMAL: "NORMAL",
      OBJECT: "OBJECT",
      ARRAY: "ARRAY",
    }

    const parser = (current, tokens, pointers = [], extraPad) => {
      // console.log("PARSER", current, value, tokens, pointers);
      while (current < tokens.length) {
        const token = tokens[current];

        let pointer = pointers[pointers.length - 1];
        const {isKey, state} = pointer;

        if (token.type === TOKEN_TYPES.LEFT_BRACE) {
          if (state === PARSER_STATES.ARRAY) {
            globalCounter += 1;
            allLines.push({pad: pointers.length - 1 + extraPad, keyType: 'number', key: pointer.key});
          }

          if (state === PARSER_STATES.NULL) {
            pointer.state = PARSER_STATES.OBJECT;
            pointer.isKey = true;
            pointer.key = null;
          } else {
            pointers.push({key: null, state: PARSER_STATES.OBJECT, isKey: true});
          }
        } else if (token.type === TOKEN_TYPES.RIGHT_BRACE) {
          if (pointers.length > 1) {
            pointers.pop();
            if (pointers[pointers.length - 1].state === PARSER_STATES.ARRAY) {
              pointers[pointers.length - 1].key += 1;
            } else {
              pointers[pointers.length - 1].isKey = true;
            }
          }
        } else if (token.type === TOKEN_TYPES.COMMA) {
          // DO NOTHING
        } else if (token.type === TOKEN_TYPES.COLON) {
          // DO NOTHING
        } else if (token.type === TOKEN_TYPES.LEFT_BRACKET) {
          if (state === PARSER_STATES.ARRAY) {
            globalCounter += 1;
            allLines.push({pad: pointers.length - 1 + extraPad, keyType: 'number', key: pointer.key});
          }

          if (state === PARSER_STATES.NULL) {
            pointer.state = PARSER_STATES.ARRAY;
            pointer.isKey = false;
            pointer.key = 0;
            globalCounter += 2;

            allLines.push({pad: pointers.length - 1 + extraPad, valueType: 'bracket', value: '['});
            extraPad = 1
          } else {
            pointers.push({key: 0, state: PARSER_STATES.ARRAY, isKey: false});
            globalCounter += 1;
            let lastLine = allLines[allLines.length - 1];
            lastLine.valueType = 'bracket';
            lastLine.value = '['
          }
        } else if (token.type === TOKEN_TYPES.RIGHT_BRACKET) {
          if (pointers.length > 1) {
            pointers.pop();
            if (pointers[pointers.length - 1].state === PARSER_STATES.ARRAY) {
              pointers[pointers.length - 1].key += 1;
            } else {
              pointers[pointers.length - 1].isKey = true;
            }
          }

          allLines.push({pad: pointers.length - 1 + extraPad, valueType: 'bracket', value: ']'});
        } else if (token.type === TOKEN_TYPES.STRING) {
          if (state === PARSER_STATES.ARRAY) {
            globalCounter += 1;
            allLines.push({pad: pointers.length - 1 + extraPad, keyType: 'number', key: pointer.key});
          }

          if (state === PARSER_STATES.OBJECT && isKey) {
            pointer.key = token.value;
            pointer.isKey = false;
            globalCounter += 1;

            allLines.push({pad: pointers.length - 1 + extraPad, keyType: 'string', key: pointer.key});
          } else {
            if (state === PARSER_STATES.ARRAY) {
              pointer.key++;
            } else {
              pointer.isKey = true;
            }
            pointer.isKey = true;

            let lastLine = allLines[allLines.length - 1];
            lastLine.valueType = 'string';
            lastLine.value = token.value;
          }
        } else if (token.type === TOKEN_TYPES.NUMBER) {
          if (state === PARSER_STATES.ARRAY) {
            pointer.key++;
            globalCounter += 1;
            allLines.push({pad: pointers.length - 1 + extraPad, keyType: 'number', key: pointer.key});
          } else {
            pointer.isKey = true;
          }
          let lastLine = allLines[allLines.length - 1];
          lastLine.valueType = 'number';
          lastLine.value = +token.value;
        } else if (token.type === TOKEN_TYPES.TRUE) {
          if (state === PARSER_STATES.ARRAY) {
            pointer.key++;
            globalCounter += 1;
            allLines.push({pad: pointers.length - 1 + extraPad, keyType: 'number', key: pointer.key});
          } else {
            pointer.isKey = true;
          }
          let lastLine = allLines[allLines.length - 1];
          lastLine.valueType = 'boolean';
          lastLine.value = true;
        } else if (token.type === TOKEN_TYPES.FALSE) {
          if (state === PARSER_STATES.ARRAY) {
            pointer.key++;
            globalCounter += 1;
            allLines.push({pad: pointers.length - 1 + extraPad, keyType: 'number', key: pointer.key});
          } else {
            pointer.isKey = true;
          }
          let lastLine = allLines[allLines.length - 1];
          lastLine.valueType = 'boolean';
          lastLine.value = false;
        } else if (token.type === TOKEN_TYPES.NULL) {
          if (state === PARSER_STATES.ARRAY) {
            pointer.key++;
            globalCounter += 1;
            allLines.push({pad: pointers.length - 1 + extraPad, keyType: 'number', key: pointer.key});
          } else {
            pointer.isKey = true;
          }
          let lastLine = allLines[allLines.length - 1];
          lastLine.valueType = 'null';
          lastLine.value = null;
        } else {
          console.error(state, current, token, tokens);
          throw new TypeError(token.type)
        }

        current++;
      }

      return [current, pointers, extraPad];
    }

    // A function for shimming scheduler.yield and setTimeout:
    function yieldToMain() {
      // Use scheduler.yield if it exists:
      if ('scheduler' in window && 'yield' in scheduler) {
        return scheduler.yield();
      }

      // Fall back to setTimeout:
      return new Promise(resolve => {
        setTimeout(resolve, 0);
      });
    }

    let currentLine = 0;

    function renderCanvas() {
      linesShown = Math.floor((document.body.offsetHeight - 74) / 28) - 1;
      let start = Math.max(0, Math.floor((totalScrolled * 28 - 74) / 28))
      // console.log(start, start + linesShown);

      canvas.innerHTML = '';
      virtualDom = document.createDocumentFragment();
      for (let i = 0; i <= linesShown; i++) {
        const line = allLines[i + start];
        if (!line) continue;
        const el = baseLineElement.cloneNode(true);
        const {key, keyType, value, valueType, pad} = line;

        // Padding
        for (let j = 0; j < pad; j++) {
          const col = document.createElement('span');
          col.classList.add('column');
          el.prepend(col);
        }

        // key
        if (typeof key !== 'undefined') {
          let keyEl = el.querySelector('.key');
          keyEl.classList.add(keyType);
          keyEl.innerText = `${key}:`
        }

        // value
        if (typeof value !== 'undefined') {
          let valueEl = el.querySelector('.value');
          valueEl.classList.add(valueType);
          valueEl.innerText = String(value);
        }

        // el.style.top = `${((i + start) * 28)}px`
        virtualDom.appendChild(el);
      }
      canvas.appendChild(virtualDom);
    }

    function handleInfiniteScroll(e) {
      let dy = (e?.deltaY || 0)
      let dir = dy < 0 ? -1 : dy > 0 ? 1 : 0;
      scroll(dir, 5);
      renderCanvas();
    };

    function scroll(dir, lines) {
      totalScrolled = Math.max(0, Math.min(totalScrolled + dir * lines, allLines.length));
    }

    window.addEventListener("wheel", handleInfiniteScroll);
    document.body.onkeydown = function (e) {
      var code = e.code;
      if (code === "KeyJ" || code === "ArrowDown") {
        scroll(1, 5);
        renderCanvas();
      } else if (code === "KeyK" || code === "ArrowUp") {
        scroll(-1, 5);
        renderCanvas();
      } else if (code === "PageDown") {
        scroll(1, 100);
        renderCanvas();
      } else if (code === "PageUp") {
        scroll(-1, 100);
        renderCanvas();
      } else if (code === "Home") {
        totalScrolled = 0;
        renderCanvas();
      } else if (code === "End") {
        totalScrolled = allLines.length - linesShown;
        renderCanvas();
      } else {
        console.log(e);
      }
    };

  </script>
</body>

</html>
