<!DOCTYPE >
<html>
  <head>
    <style>
      @font-face {
        font-family: Inter;
        src: url(./inter_variable.ttf);
      }

      * {
        box-sizing: border-box;
      }

      html {
        font-family: "Inter";
        height: 100dvh;
        margin: 0;
        padding-bottom: 1px;
      }

      body {
        margin: 0;
        height: 100dvh;
        display: grid;
        justify-content: center;
        align-items: center;
      }

      h1 {
        font-weight: 700;
        line-height: 1.2;
      }

      h2 {
        font-size: 24px;
        font-weight: 400;
      }

      #menu {
        text-align: center;
      }

      #canvas {
        position: relative;
        overflow: hidden;
        pointer-events: none;
      }

      #title {
        display: flex; 
        justify-content: space-between;
        height: 74px; 
        padding-top: 24px; 
        padding-bottom: 10px;
      }

      #viewer h1 {
        font-size: 32px;
        margin: 0;
      }

      #viewer {
        height: 100%;
        max-height: 100dvh;
        /* height: 400px!important; */
        width: 100dvw;
        max-width: 638px;
        justify-content: start;
        overflow-y: scroll;
      }

      .line {
        display: flex;
        align-items: center;

        position: absolute;
      }

      .column {
        flex-shrink: 0;
        width: 24px;
        height: 100%;
        border-left: 1px solid #bfbfbf;
        display: inline-block;
        position: relative;
        left: 1px;
      }

      .line {
        height: 28px;
        max-height: 28px;
      }

      .key {
        width: 0px;
      }

      .key.string,
      .string_key {
        width: auto;
        color: #4e9590;
        padding-right: 4px;
        font-weight: 400;
      }

      .value {
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .key.number,
      .number_key {
        width: auto;
        color: #bfbfbf;
        padding-right: 4px;
        font-weight: 400;
      }

      .value.object {
        color: #d557da;
      }
      .value.string {
        color: #e86767;
      }
      .value.boolean,
      .value.number {
        color: #3d64ff;
      }
      .value.symbol {
        color: #f2cab8;
        font-weight: 700;
      }
    </style>
  </head>

  <body>
    <section id="menu">
      <h1>JSON Tree Viewer</h1>
      <h2>
        Simple JSON Viewer that runs compvarely on-client. No data exchange
      </h2>
      <input
        type="file"
        id="fileInput"
        accept="application/JSON"
        style="display: none"
      />
      <button id="fileSelect" type="button">Load JSON</button>
      <p style="color: #bf0e0e; display: none">
        Invalid file. Please load a valid JSON file.
      </p>
    </section>
    <section id="viewer" style="display: none">
      <div id="title" >
        <h1 id="filename"></h1>
        <button id="back">X</button>
      </div>
      <div id="canvas"></div>
    </section>
    <script>
      const CHUNK_SIZE = 0x200000;
      const TOKEN_TYPES = {
        LEFT_BRACE: Symbol(),
        RIGHT_BRACE: Symbol(),
        LEFT_BRACKET: Symbol(),
        RIGHT_BRACKET: Symbol(),
        COLON: Symbol(),
        COMMA: Symbol(),
        STRING: Symbol(),
        NUMBER: Symbol(),
        TRUE: Symbol(),
        FALSE: Symbol(),
        NULL: Symbol(),
      };

      const LEXER_STATES = {
        NORMAL: Symbol(),
        NUMBER: Symbol(),
        STRING: Symbol(),
        STRING_ESCAPING: Symbol(),
        TRUE_T: Symbol(),
        TRUE_R: Symbol(),
        TRUE_U: Symbol(),
        // TRUE_E: Symbol(),
        FALSE_F: Symbol(),
        FALSE_A: Symbol(),
        FALSE_L: Symbol(),
        FALSE_S: Symbol(),
        // FALSE_E: Symbol(),
        NULL_N: Symbol(),
        NULL_U: Symbol(),
        NULL_L1: Symbol(),
        // NULL_L2: Symbol(),
      };

      const PARSER_STATES = {
        NULL: Symbol(),
        OBJECT: Symbol(),
        ARRAY: Symbol(),
      };

      // elements
      const back = document.getElementById("back");
      const menu = document.getElementById("menu");

      const fileName = document.getElementById("filename");
      const fileSelect = document.getElementById("fileSelect");
      const fileInput = document.getElementById("fileInput");

      const viewer = document.getElementById("viewer");
      const canvas = document.getElementById("canvas");

      // index
      let i = 0;

      let lineCounter;
      let virtualDom = null;
      let pads = [];
      let keys = [];
      let values = [];
      let linesShown = Math.floor(document.body.clientHeight / 28) + 10;

      //

      let file;
      let filePageLength;

      let buffer = new ArrayBuffer(CHUNK_SIZE);
      let reader;

      // read + decode
      let decoder = new TextDecoder("utf-8");
      let done;
      let readPages;
      let input;

      let consumedValueIndex;
      let lexerState;
      let char;

      let pointers;
      let pointer;

      let pointersLen;
      let token;
      let extraPad;

      let oldCounter;

      // html

      const baseLineElement = document.createElement("div");
      baseLineElement.classList.add("line");
      baseLineElement.innerHTML = `<span class="key"></span><span class="value"></span>`;

      const baseCol = document.createElement("span");
      baseCol.classList.add("column");

      // Large virtual scroller
      var th = 0; // total theorical height (len(rows) * rowHeight)
      var h = canvas.clientHeight; // virtual scroller scroll height
      var ph = h / 100; // virtual page height
      var n = Math.ceil(th / ph); // number of virtual pages
      var vp = viewer.clientHeight; // actual DOM viewer height
      var cj = (th - h) / (n - 1); // "jumpiness" coefficient

      var rh = 28; // row height

      fileSelect.onclick = (e) => {
        fileInput.value = null;
        fileInput.click();
      };

      function setLine(pad, key, value) {
        pads.push(pad);
        keys.push(key);
        values.push(value);
      }

      back.onclick = () => {
        menu.style.display = "block";
        viewer.style.display = "none";
        canvas.innerHTML = '';
      }

      fileInput.onchange = async (e) => {
        performance.mark("fileRead");

        file = fileInput.files[0];
        reader = file.stream().getReader({ mode: "byob" });
        fileName.innerText = file.name;
        filePageLength = Math.ceil(file.size / CHUNK_SIZE);

        // read + decode
        done = false;
        readPages = 0;

        lexerState = LEXER_STATES.NORMAL;

        // parser
        pads = [];
        keys = [];
        values = [];

        pointers = [{ key: 0, state: PARSER_STATES.NULL, isKey: false }];
        pointer = pointers[0];
        // we start a 0 for padding purposes

        pointersLen = 0;
        extraPad = 0;

        oldCounter = 0;

        // html
        lineCounter = 0;
        virtualDom = document.createDocumentFragment();

        viewer.style.display = "block";
        menu.style.display = "none";

        async function seek() {
          performance.mark("read");

          const result = await reader.read(new Uint8Array(buffer));

          buffer = result.value.buffer;
          if (result.done) {
            done = true;
            performance.measure("fileRead", "fileRead");
            return;
          }

          performance.measure("read", "read");
          performance.mark("decode");
          input = decoder.decode(result.value);
          performance.measure("decode", "decode");

          // lexer+parser
          i = 0;
          let subStart;
          performance.mark("lexer_parser");
          consumedValueIndex = 0;
          let inputLen = input.length;

          while (i < inputLen) {
            char = input[i];

            switch (lexerState) {
              case LEXER_STATES.NORMAL:
                switch (char) {
                  // ignore empty space
                  case " ":
                  case "\t":
                  case "\r":
                  case "\n":
                    // do nothing
                    break;

                  // string start
                  case '"':
                    lexerState = LEXER_STATES.STRING;
                    subStart = i + 1;
                    break;

                  // number
                  case "0":
                  case "1":
                  case "2":
                  case "3":
                  case "4":
                  case "5":
                  case "6":
                  case "7":
                  case "8":
                  case "9":
                  case ".":
                  case "-":
                    lexerState = LEXER_STATES.NUMBER;
                    subStart = i;
                    break;

                  case ":":
                  case ",":
                    // do nothing
                    break;

                  case "{":
                    if (pointer.state === PARSER_STATES.ARRAY) {
                      lineCounter += 1;
                      setLine(pointersLen + extraPad, pointer.key, undefined);
                      let newPointer = {
                        key: 0,
                        state: PARSER_STATES.OBJECT,
                        isKey: true,
                      };
                      pointers.push(newPointer);
                      pointersLen++;
                      pointer = newPointer;
                    } else if (pointer.state === PARSER_STATES.NULL) {
                      pointer.state = PARSER_STATES.OBJECT;
                      pointer.isKey = true;
                      pointer.key = 0;
                    } else {
                      let newPointer = {
                        key: 0,
                        state: PARSER_STATES.OBJECT,
                        isKey: true,
                      };
                      pointers.push(newPointer);
                      pointersLen++;
                      pointer = newPointer;
                    }
                    break;

                  case "}":
                    if (pointersLen > 0) {
                      pointers.pop();
                      pointersLen--;
                      pointer = pointers[pointersLen];
                      if (pointer.state === PARSER_STATES.ARRAY) {
                        pointer.key += 1;
                      } else {
                        pointer.isKey = true;
                      }
                    }
                    break;

                  case "[":
                    if (pointer.state === PARSER_STATES.ARRAY) {
                      lineCounter += 1;
                      setLine(pointersLen + extraPad, pointer.key, undefined);

                      let newPointer = {
                        key: 0,
                        state: PARSER_STATES.ARRAY,
                        isKey: false,
                      };
                      pointers.push(newPointer);
                      pointersLen++;
                      pointer = newPointer;

                      lineCounter += 1;

                      values[pads.length-1] = TOKEN_TYPES.LEFT_BRACKET;
                    } else if (pointer.state === PARSER_STATES.NULL) {
                      pointer.state = PARSER_STATES.ARRAY;
                      pointer.isKey = false;
                      pointer.key = 0;
                      lineCounter += 2;

                      setLine(
                        pointersLen + extraPad,
                        undefined,
                        TOKEN_TYPES.LEFT_BRACKET,
                      );
                      extraPad = 1;
                    } else {
                      let newPointer = {
                        key: 0,
                        state: PARSER_STATES.ARRAY,
                        isKey: false,
                      };
                      pointers.push(newPointer);
                      pointersLen++;
                      pointer = newPointer;
                      lineCounter += 1;

                      values[pads.length-1] = TOKEN_TYPES.LEFT_BRACKET;
                    }
                    break;

                  case "]":
                    let isRoot = 0;
                    if (pointersLen > 0) {
                      pointers.pop();
                      pointersLen--;
                      pointer = pointers[pointersLen];
                      if (pointer.state === PARSER_STATES.ARRAY) {
                        pointer.key += 1;
                      } else {
                        pointer.isKey = true;
                      }
                    } else {
                      isRoot = 1;
                    }

                    setLine(
                      pointersLen + extraPad - isRoot,
                      undefined,
                      TOKEN_TYPES.RIGHT_BRACKET,
                    );
                    break;

                  // true
                  case "t":
                    lexerState = LEXER_STATES.TRUE_T;
                    subStart = i;
                    break;

                  // false
                  case "f":
                    lexerState = LEXER_STATES.FALSE_F;
                    subStart = i;
                    break;

                  // null
                  case "n":
                    lexerState = LEXER_STATES.NULL_N;
                    subStart = i;
                    break;

                  // character not recognized
                  default:
                    throw new TypeError(
                      "I dont know what this character is: " + char + " c:" + i,
                    );
                }
                break;

              case LEXER_STATES.STRING:
                if (char !== '"') {
                  if (char === "\\") {
                    lexerState = LEXER_STATES.STRING_ESCAPING;
                  }
                } else {
                  if (pointer.state === PARSER_STATES.OBJECT && pointer.isKey) {
                    pointer.key = input.substring(subStart, i);
                    pointer.isKey = false;
                    lineCounter += 1;

                    setLine(pointersLen + extraPad, pointer.key, undefined);
                  } else {
                    if (pointer.state === PARSER_STATES.ARRAY) {
                      pointer.key++;
                    } 
                    pointer.isKey = true;

                    ind = pads.length - 1;
                    values[ind] = input.substring(subStart, i);
                  }

                  lexerState = LEXER_STATES.NORMAL;
                }
                break;

              case LEXER_STATES.NUMBER:
                if (char !== "." && (char < "0" || char > "9")) {
                  if (pointer.state === PARSER_STATES.ARRAY) {
                    pointer.key++;
                    lineCounter += 1;
                    setLine(pointersLen + extraPad, pointer.key, undefined);
                  } else {
                    pointer.isKey = true;
                  }

                  ind = pads.length - 1;
                  values[ind] = +input.substring(subStart, i);

                  lexerState = LEXER_STATES.NORMAL;
                  // after number end, go back 1 char
                  i--;
                }
                break;

              case LEXER_STATES.TRUE_T:
                if (char === "r") {
                  lexerState = LEXER_STATES.TRUE_R;
                } else {
                  throw new TypeError(
                    "I dont know what this character is: " + char + " c:" + i,
                  );
                }
                break;

              case LEXER_STATES.TRUE_R:
                if (char === "u") {
                  lexerState = LEXER_STATES.TRUE_U;
                } else {
                  throw new TypeError(
                    "I dont know what this character is: " + char + " c:" + i,
                  );
                }
                break;

              case LEXER_STATES.TRUE_U:
                if (char === "e") {
                  if (pointer.state === PARSER_STATES.ARRAY) {
                    pointer.key++;
                    lineCounter += 1;
                    setLine(pointersLen + extraPad, pointer.key, undefined);
                  } else {
                    pointer.isKey = true;
                  }

                  values[pads.length-1] = true;
                  lexerState = LEXER_STATES.NORMAL;
                } else {
                  throw new TypeError(
                    "I dont know what this character is: " + char + " c:" + i,
                  );
                }
                break;

              case LEXER_STATES.FALSE_F:
                if (char === "a") {
                  lexerState = LEXER_STATES.FALSE_A;
                } else {
                  throw new TypeError(
                    "I dont know what this character is: " + char + " c:" + i,
                  );
                }
                break;

              case LEXER_STATES.FALSE_A:
                if (char === "l") {
                  lexerState = LEXER_STATES.FALSE_L;
                } else {
                  throw new TypeError(
                    "I dont know what this character is: " + char + " c:" + i,
                  );
                }
                break;

              case LEXER_STATES.FALSE_L:
                if (char === "s") {
                  lexerState = LEXER_STATES.FALSE_S;
                } else {
                  throw new TypeError(
                    "I dont know what this character is: " + char + " c:" + i,
                  );
                }
                break;

              case LEXER_STATES.FALSE_S:
                if (char === "e") {
                  if (pointer.state === PARSER_STATES.ARRAY) {
                    pointer.key++;
                    lineCounter += 1;
                    setLine(pointersLen + extraPad, pointer.key, undefined);
                  } else {
                    pointer.isKey = true;
                  }

                  values[pads.length-1] = false;
                  lexerState = LEXER_STATES.NORMAL;
                } else {
                  throw new TypeError(
                    "I dont know what this character is: " + char + " c:" + i,
                  );
                }
                break;

              case LEXER_STATES.NULL_N:
                if (char === "u") {
                  lexerState = LEXER_STATES.NULL_U;
                } else {
                  throw new TypeError(
                    "I dont know what this character is: " + char + " c:" + i,
                  );
                }
                break;

              case LEXER_STATES.NULL_U:
                if (char === "l") {
                  lexerState = LEXER_STATES.NULL_L1;
                } else {
                  throw new TypeError(
                    "I dont know what this character is: " + char + " c:" + i,
                  );
                }
                break;

              case LEXER_STATES.NULL_L1:
                if (char === "l") {
                  if (pointer.state === PARSER_STATES.ARRAY) {
                    pointer.key++;
                    lineCounter += 1;
                    setLine(pointersLen + extraPad, pointer.key, undefined);
                  } else {
                    pointer.isKey = true;
                  }

                  values[pads.length-1] = null;
                  lexerState = LEXER_STATES.NORMAL;
                } else {
                  throw new TypeError(
                    "I dont know what this character is: " + char + " c:" + i,
                  );
                }
                break;

              case LEXER_STATES.STRING_ESCAPING:
                lexerState = LEXER_STATES.STRING;
                break;
            }

            ++i;
          }
          performance.measure("lexer_parser", "lexer_parser");

          oldCounter = lineCounter;

          // set height for virtual scroller
          th = lineCounter * rh + 74; // virtual height

          if (th < 1e7) {
            // just one page
            h = ph = th;
            n = 1;
            cj = 0;
          } else {
            // break into pages
            h = 1e7;
            ph = h / 100;
            n = Math.ceil(th / ph);
            cj = (th - h) / (n - 1);
          }

          vp = viewer.clientHeight;
          canvas.style.height = h;
        }

        await seek();
        renderFreshCanvas();

        let deadline = performance.now() + 50;

        async function doWork() {
          if (!done) {
            await seek();
            if (
              navigator?.scheduling?.isInputPending() ||
              performance.now() >= deadline
            ) {
              await yieldToMain();
              deadline = performance.now() + 50;
            }
            doWork();
          }
        }

        await doWork();
      };

      // A function for shimming scheduler.yield and setTimeout:
      function yieldToMain() {
        // Use scheduler.yield if it exists:
        if ("scheduler" in window && "yield" in scheduler) {
          return scheduler.yield();
        }

        // Fall back to setTimeout:
        return new Promise((resolve) => {
          setTimeout(resolve, 0);
        });
      }

      window.addEventListener("resize", (event) => {
        linesShown = Math.floor(document.body.clientHeight / 28) + 10;

        vp = viewer.clientHeight; // viewer height

        renderFreshCanvas();
      });

      function renderFreshCanvas() {
        var y = viewer.scrollTop + virtualScrollOffset,
          buffer = vp,
          top = Math.floor((y - buffer) / rh),
          bottom = Math.ceil((y + vp + buffer) / rh);

        start = Math.max(0, top);
        bottom = Math.min(th / rh, bottom);

        let diff = bottom - start;

        canvas.innerHTML = "";
        virtualDom = document.createDocumentFragment();
        for (i = 0; i <= diff; ++i) {
          let ind = pads.length - 1;
          if (i + start > ind) continue;

          const pad = pads[i + start];
          const key = keys[i + start];
          const value = values[i + start];

          const el = baseLineElement.cloneNode(true);

          // Padding
          for (var j = 0; j < pad; j++) {
            const col = baseCol.cloneNode();
            el.prepend(col);
          }

          // key
          if (typeof key !== "undefined") {
            let keyEl = el.querySelector(".key");
            keyEl.classList.add(typeof key);
            keyEl.innerText = `${key}:`;
          }

          // value
          let valueType = typeof value;
          if (valueType !== "undefined") {
            let valueEl = el.querySelector(".value");
            valueEl.classList.add(valueType);
            if (value === TOKEN_TYPES.LEFT_BRACKET) {
              valueEl.innerText = "[";
            } else if (value === TOKEN_TYPES.RIGHT_BRACKET) {
              valueEl.innerText = "]";
            } else if (valueType === "string") {
              valueEl.innerText = `"${String(value)}"`;
            } else {
              valueEl.innerText = String(value);
            }
          }

          el.style.top = (start + i) * rh - virtualScrollOffset;
          virtualDom.appendChild(el);
        }
        canvas.appendChild(virtualDom);
      }

      // Large virtual scroller
      var virtualScrollPage = 0; // current page
      var virtualScrollOffset = 0; // current page offset
      var prevScrollTop = 0;

      var content = canvas;

      // viewport.css("height", vp);
      // content.css("height", h);

      viewer.addEventListener("scroll", onScroll);

      function onScroll() {
        var scrollTop = viewer.scrollTop;

        if (Math.abs(scrollTop - prevScrollTop) > vp) {
          onJump();
        } else {
          onNearScroll();
        }

        renderFreshCanvas();
      }

      function onNearScroll() {
        var scrollTop = viewer.scrollTop;

        // next virtualScrollPage
        if (scrollTop + virtualScrollOffset > (virtualScrollPage + 1) * ph) {
          virtualScrollPage++;
          virtualScrollOffset = Math.round(virtualScrollPage * cj);
          viewer.scrollTop = prevScrollTop = scrollTop - cj;
        } else if (scrollTop + virtualScrollOffset < virtualScrollPage * ph) {
          // prev virtualScrollPage
          virtualScrollPage--;
          virtualScrollOffset = Math.round(virtualScrollPage * cj);
          viewer.scrollTop = prevScrollTop = scrollTop + cj;
        } else {
          prevScrollTop = scrollTop;
        }
      }

      function onJump() {
        var scrollTop = viewer.scrollTop;
        virtualScrollPage = Math.floor(
          scrollTop * ((th - vp) / (h - vp)) * (1 / ph),
        );
        virtualScrollOffset = Math.round(virtualScrollPage * cj);
        prevScrollTop = scrollTop;
      }
    </script>
  </body>
</html>
