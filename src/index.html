<!DOCTYPE >
<html>
  <head>
    <style>
      @font-face {
        font-family: Inter;
        src: url(./inter_variable.ttf);
      }

      * {
        box-sizing: border-box;
      }

      html {
        font-family: "Inter";
        height: 100dvh;
        margin: 0;
        padding-bottom: 1px;
      }

      body {
        margin: 0;
        height: 100dvh;
        display: grid;
        justify-content: center;
        align-items: center;
      }

      h1 {
        font-weight: 700;
        line-height: 1.2;
      }

      h2 {
        font-size: 24px;
        font-weight: 400;
      }

      #menu {
        text-align: center;
      }

      #canvas {
        position: relative;
        overflow: hidden;
        pointer-events: none;
      }

      #viewer h1 {
        font-size: 32px;
        padding-top: 24px;
        padding-bottom: 10px;
        margin: 0;
        height: 74px;
      }

      #viewer {
        height: 100%;
        max-height: 100dvh;
        /* height: 400px!important; */
        width: 100dvw;
        max-width: 638px;
        justify-content: start;
        overflow-y: scroll;
      }

      .line {
        display: flex;
        align-items: center;

        position: absolute;
      }

      .column {
        flex-shrink: 0;
        width: 24px;
        height: 100%;
        border-left: 1px solid #bfbfbf;
        display: inline-block;
        position: relative;
        left: 1px;
      }

      .line {
        height: 28px;
        max-height: 28px;
      }

      .key {
        width: 0px;
      }

      .key.string,
      .string_key {
        width: auto;
        color: #4e9590;
        padding-right: 4px;
        font-weight: 400;
      }

      .value {
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .key.number,
      .number_key {
        width: auto;
        color: #bfbfbf;
        padding-right: 4px;
        font-weight: 400;
      }

      .symbol {
        color: #f2cab8;
        font-weight: 700;
      }
    </style>
  </head>

  <body>
    <section id="menu">
      <h1>JSON Tree Viewer</h1>
      <h2>
        Simple JSON Viewer that runs compvarely on-client. No data exchange
      </h2>
      <input
        type="file"
        id="fileInput"
        accept="application/JSON"
        style="display: none"
      />
      <button id="fileSelect" type="button">Load JSON</button>
      <p style="color: #bf0e0e; display: none">
        Invalid file. Please load a valid JSON file.
      </p>
    </section>
    <section id="viewer" style="display: none">
      <h1 id="filename"></h1>
      <div id="canvas"></div>
    </section>
    <script>
      // TODO: Allocate memory in large pages for pads, keys, values, maybe tokens
      // TODO: Identify why minor GC is running often (it is due to large memory usage, probably)
      // TODO: Benchmark file.slice vs BYOBReader + ArrayBuffer

      // TODO: check why this number is the max DataView buffer size
      const CHUNK_SIZE = 0x200000;
      const TOKEN_TYPES = {
        LEFT_BRACE: Symbol(),
        RIGHT_BRACE: Symbol(),
        LEFT_BRACKET: Symbol(),
        RIGHT_BRACKET: Symbol(),
        COLON: Symbol(),
        COMMA: Symbol(),
        STRING: Symbol(),
        NUMBER: Symbol(),
        TRUE: Symbol(),
        FALSE: Symbol(),
        NULL: Symbol(),
      };

      const LEXER_STATES = {
        NORMAL: Symbol(),
        NUMBER: Symbol(),
        STRING: Symbol(),
        STRING_ESCAPING: Symbol(),
        TRUE_T: Symbol(),
        TRUE_R: Symbol(),
        TRUE_U: Symbol(),
        // TRUE_E: Symbol(),
        FALSE_F: Symbol(),
        FALSE_A: Symbol(),
        FALSE_L: Symbol(),
        FALSE_S: Symbol(),
        // FALSE_E: Symbol(),
        NULL_N: Symbol(),
        NULL_U: Symbol(),
        NULL_L1: Symbol(),
        // NULL_L2: Symbol(),
      };

      const PARSER_STATES = {
        NULL: Symbol(),
        NORMAL: Symbol(),
        OBJECT: Symbol(),
        ARRAY: Symbol(),
      };

      // elements
      const menu = document.getElementById("menu");

      const fileName = document.getElementById("filename");
      const fileSelect = document.getElementById("fileSelect");
      const fileInput = document.getElementById("fileInput");

      const viewer = document.getElementById("viewer");
      const canvas = document.getElementById("canvas");

      // index
      let i = 0;

      let lineCounter;
      let virtualDom = null;
      let pads = [];
      let keys = [];
      let values = [];
      let linesShown = Math.floor(document.body.clientHeight / 28) + 10;

      //

      let file;
      let filePageLength;

      // read + decode
      let decoder = new TextDecoder("utf-8");
      let done;
      let readPages;
      let input;

      // This size for tokens array is an heuristic that for every 10 chars there will be ~1 token
      let tokens = new Array(Math.ceil(CHUNK_SIZE / 5));
      let tokenValues = new Array(Math.ceil(CHUNK_SIZE / 10));
      let valueIndex;
      let consumedValueIndex;
      let tokensToParse;
      let lexerState;
      let char;

      let parserState;
      let pointers;
      let pointer;

      let pointersLen;
      let token;
      let extraPad;

      let oldCounter;

      // html

      const baseLineElement = document.createElement("div");
      baseLineElement.classList.add("line");
      baseLineElement.innerHTML = `<span class="key"></span><span class="value"></span>`;

      const baseCol = document.createElement("span");
      baseCol.classList.add("column");

      // Large virtual scroller
      var th = 0; // total theorical height (len(rows) * rowHeight)
      var h = canvas.clientHeight; // virtual scroller scroll height
      var ph = h / 100; // virtual page height
      var n = Math.ceil(th / ph); // number of virtual pages
      var vp = viewer.clientHeight; // actual DOM viewer height
      var cj = (th - h) / (n - 1); // "jumpiness" coefficient

      var rh = 28; // row height

      fileSelect.onclick = (e) => {
        fileInput.click();
      };

      function setLine(pad, key, value) {
        pads.push(pad);
        keys.push(key);
        values.push(value);
      }

      fileInput.onchange = async (e) => {
        // console.log('changed', fileInput.files[0]);
        performance.mark("fileRead");

        file = fileInput.files[0];
        fileName.innerText = file.name;
        filePageLength = Math.ceil(file.size / CHUNK_SIZE);

        // read + decode
        done = false;
        readPages = 0;

        lexerState = LEXER_STATES.NORMAL;

        // parser
        pads = [];
        keys = [];
        values = [];

        tokensToParse = 0;

        parserState = PARSER_STATES.NORMAL;
        pointers = [{ key: null, state: PARSER_STATES.NULL, isKey: false }];
        pointer = pointers[0];
        // we start a 0 for padding purposes

        pointersLen = 0;
        extraPad = 0;

        oldCounter = 0;

        // html
        lineCounter = 0;
        virtualDom = document.createDocumentFragment();

        viewer.style.display = "block";
        menu.style.display = "none";

        async function seek() {
          performance.mark("read");

          const result = await file
            .slice(readPages * CHUNK_SIZE, (readPages + 1) * CHUNK_SIZE)
            .arrayBuffer();
          readPages++;

          if (readPages > filePageLength) {
            done = true;
            performance.measure("fileRead", "fileRead");

            // console.log('sizeToLines', file.size / lineCounter)
            return;
          }

          performance.measure("read", "read");
          performance.mark("decode");
          input = decoder.decode(result);
          performance.measure("decode", "decode");

          // lexer
          i = 0;
          let subStart;
          performance.mark("lexer");
          tokensToParse = 0;
          valueIndex = 0;
          consumedValueIndex = 0;
          let inputLen = input.length;
          // console.log('scanning', inputLen);
          while (i < inputLen) {
            char = input[i];

            switch (lexerState) {
              case LEXER_STATES.NORMAL:
                switch (char) {
                  // ignore empty space
                  case " ":
                  case "\t":
                  case "\r":
                  case "\n":
                    // do nothing
                    break;

                  // string start
                  case '"':
                    lexerState = LEXER_STATES.STRING;
                    subStart = i + 1;
                    break;

                  // number
                  case "0":
                  case "1":
                  case "2":
                  case "3":
                  case "4":
                  case "5":
                  case "6":
                  case "7":
                  case "8":
                  case "9":
                  case ".":
                  case "-":
                    lexerState = LEXER_STATES.NUMBER;
                    subStart = i;
                    break;

                  case ":":
                    tokens[tokensToParse++] = TOKEN_TYPES.COLON;
                    break;

                  case ",":
                    tokens[tokensToParse++] = TOKEN_TYPES.COMMA;
                    break;

                  case "{":
                    tokens[tokensToParse++] = TOKEN_TYPES.LEFT_BRACE;
                    break;

                  case "}":
                    tokens[tokensToParse++] = TOKEN_TYPES.RIGHT_BRACE;
                    break;

                  case "[":
                    tokens[tokensToParse++] = TOKEN_TYPES.LEFT_BRACKET;
                    break;

                  case "]":
                    tokens[tokensToParse++] = TOKEN_TYPES.RIGHT_BRACKET;
                    break;

                  // true
                  case "t":
                    lexerState = LEXER_STATES.TRUE_T;
                    subStart = i;
                    break;

                  // false
                  case "f":
                    lexerState = LEXER_STATES.FALSE_F;
                    subStart = i;
                    break;

                  // null
                  case "n":
                    lexerState = LEXER_STATES.NULL_N;
                    subStart = i;
                    break;

                  // character not recognized
                  default:
                    throw new TypeError(
                      "I dont know what this character is: " + char + " c:" + i,
                    );
                }
                break;

              case LEXER_STATES.STRING:
                if (char !== '"') {
                  if (char === "\\") {
                    lexerState = LEXER_STATES.STRING_ESCAPING;
                  }
                } else {
                  tokenValues[valueIndex++] = input.substring(subStart, i);
                  tokens[tokensToParse++] = TOKEN_TYPES.STRING;
                  lexerState = LEXER_STATES.NORMAL;
                }
                break;

              case LEXER_STATES.NUMBER:
                if (char !== "." && (char < "0" || char > "9")) {
                  tokenValues[valueIndex++] = input.substring(subStart, i);
                  tokens[tokensToParse++] = TOKEN_TYPES.NUMBER;
                  lexerState = LEXER_STATES.NORMAL;
                  // after number end, go back 1 char
                  i--;
                }
                break;

              case LEXER_STATES.TRUE_T:
                if (char === "r") {
                  lexerState = LEXER_STATES.TRUE_R;
                } else {
                  throw new TypeError(
                    "I dont know what this character is: " + char + " c:" + i,
                  );
                }
                break;

              case LEXER_STATES.TRUE_R:
                if (char === "u") {
                  lexerState = LEXER_STATES.TRUE_U;
                } else {
                  throw new TypeError(
                    "I dont know what this character is: " + char + " c:" + i,
                  );
                }
                break;

              case LEXER_STATES.TRUE_U:
                if (char === "e") {
                  tokens[tokensToParse++] = TOKEN_TYPES.TRUE;
                  lexerState = LEXER_STATES.NORMAL;
                } else {
                  throw new TypeError(
                    "I dont know what this character is: " + char + " c:" + i,
                  );
                }
                break;

              case LEXER_STATES.FALSE_F:
                if (char === "a") {
                  lexerState = LEXER_STATES.FALSE_A;
                } else {
                  throw new TypeError(
                    "I dont know what this character is: " + char + " c:" + i,
                  );
                }
                break;

              case LEXER_STATES.FALSE_A:
                if (char === "l") {
                  lexerState = LEXER_STATES.FALSE_L;
                } else {
                  throw new TypeError(
                    "I dont know what this character is: " + char + " c:" + i,
                  );
                }
                break;

              case LEXER_STATES.FALSE_L:
                if (char === "s") {
                  lexerState = LEXER_STATES.FALSE_S;
                } else {
                  throw new TypeError(
                    "I dont know what this character is: " + char + " c:" + i,
                  );
                }
                break;

              case LEXER_STATES.FALSE_S:
                if (char === "e") {
                  tokens[tokensToParse++] = TOKEN_TYPES.FALSE;
                  lexerState = LEXER_STATES.NORMAL;
                } else {
                  throw new TypeError(
                    "I dont know what this character is: " + char + " c:" + i,
                  );
                }
                break;

              case LEXER_STATES.NULL_N:
                if (char === "u") {
                  lexerState = LEXER_STATES.NULL_U;
                } else {
                  throw new TypeError(
                    "I dont know what this character is: " + char + " c:" + i,
                  );
                }
                break;

              case LEXER_STATES.NULL_U:
                if (char === "l") {
                  lexerState = LEXER_STATES.NULL_L1;
                } else {
                  throw new TypeError(
                    "I dont know what this character is: " + char + " c:" + i,
                  );
                }
                break;

              case LEXER_STATES.NULL_L1:
                if (char === "l") {
                  tokens[tokensToParse++] = TOKEN_TYPES.NULL;
                  lexerState = LEXER_STATES.NORMAL;
                } else {
                  throw new TypeError(
                    "I dont know what this character is: " + char + " c:" + i,
                  );
                }
                break;

              case LEXER_STATES.STRING_ESCAPING:
                lexerState = LEXER_STATES.STRING;
                break;
            }

            ++i;
          }
          performance.measure("lexer", "lexer");

          // parser
          performance.mark("parser");
          // console.log('parsing ', tokensToParse);
          i = 0;
          while (i < tokensToParse) {
            let ind = pads.length - 1;
            token = tokens[i];
            parserState = pointer.state;

            switch (token) {
              case TOKEN_TYPES.STRING:
                if (parserState === PARSER_STATES.ARRAY) {
                  lineCounter += 1;
                  setLine(pointersLen + extraPad, pointer.key, undefined);
                }

                if (parserState === PARSER_STATES.OBJECT && pointer.isKey) {
                  console.log(tokenValues[consumedValueIndex])
                  pointer.key = tokenValues[consumedValueIndex++];
                  pointer.isKey = false;
                  lineCounter += 1;

                  setLine(pointersLen + extraPad, pointer.key, undefined);
                } else {
                  if (parserState === PARSER_STATES.ARRAY) {
                    pointer.key++;
                  } 
                  pointer.isKey = true;

                  ind = pads.length - 1;
                  console.log(tokenValues[consumedValueIndex])
                  values[ind] = tokenValues[consumedValueIndex++];
                }
                break;

              case TOKEN_TYPES.NUMBER:
                if (parserState === PARSER_STATES.ARRAY) {
                  pointer.key++;
                  lineCounter += 1;
                  setLine(pointersLen + extraPad, pointer.key, undefined);
                } else {
                  pointer.isKey = true;
                }

                ind = pads.length - 1;
                  console.log(tokenValues[consumedValueIndex])
                values[ind] = +tokenValues[consumedValueIndex++];
                break;

              case TOKEN_TYPES.COLON:
              case TOKEN_TYPES.COMMA:
                break;

              case TOKEN_TYPES.LEFT_BRACE:
                if (parserState === PARSER_STATES.ARRAY) {
                  lineCounter += 1;
                  setLine(pointersLen + extraPad, pointer.key, undefined);
                  let newPointer = {
                    key: null,
                    state: PARSER_STATES.OBJECT,
                    isKey: true,
                  };
                  pointers.push(newPointer);
                  pointersLen++;
                  pointer = newPointer;
                } else if (parserState === PARSER_STATES.NULL) {
                  pointer.state = PARSER_STATES.OBJECT;
                  pointer.isKey = true;
                  pointer.key = 0;
                } else {
                  let newPointer = {
                    key: null,
                    state: PARSER_STATES.OBJECT,
                    isKey: true,
                  };
                  pointers.push(newPointer);
                  pointersLen++;
                  pointer = newPointer;
                }
                break;

              case TOKEN_TYPES.RIGHT_BRACE:
                if (pointersLen > 0) {
                  pointers.pop();
                  pointersLen--;
                  pointer = pointers[pointersLen];
                  if (pointer.state === PARSER_STATES.ARRAY) {
                    pointer.key += 1;
                  } else {
                    pointer.isKey = true;
                  }
                }
                break;

              case TOKEN_TYPES.LEFT_BRACKET:
                if (parserState === PARSER_STATES.ARRAY) {
                  lineCounter += 1;
                  setLine(pointersLen + extraPad, pointer.key, undefined);

                  let newPointer = {
                    key: 0,
                    state: PARSER_STATES.ARRAY,
                    isKey: false,
                  };
                  pointers.push(newPointer);
                  pointersLen++;
                  pointer = newPointer;

                  lineCounter += 1;

                  ind = pads.length - 1;
                  values[ind] = TOKEN_TYPES.LEFT_BRACKET;
                } else if (parserState === PARSER_STATES.NULL) {
                  pointer.state = PARSER_STATES.ARRAY;
                  pointer.isKey = false;
                  pointer.key = 0;
                  lineCounter += 2;

                  setLine(
                    pointersLen + extraPad,
                    undefined,
                    TOKEN_TYPES.LEFT_BRACKET,
                  );
                  extraPad = 1;
                } else {
                  let newPointer = {
                    key: 0,
                    state: PARSER_STATES.ARRAY,
                    isKey: false,
                  };
                  pointers.push(newPointer);
                  pointersLen++;
                  pointer = newPointer;
                  lineCounter += 1;

                  ind = pads.length - 1;
                  values[ind] = TOKEN_TYPES.LEFT_BRACKET;
                }
                break;

              case TOKEN_TYPES.RIGHT_BRACKET:
                let isRoot = 0;
                if (pointersLen > 0) {
                  pointers.pop();
                  pointersLen--;
                  pointer = pointers[pointersLen];
                  if (pointer.state === PARSER_STATES.ARRAY) {
                    pointer.key += 1;
                  } else {
                    pointer.isKey = true;
                  }
                } else {
                  isRoot = 1;
                }

                setLine(
                  pointersLen + extraPad - isRoot,
                  undefined,
                  TOKEN_TYPES.RIGHT_BRACKET,
                );

                break;

              case TOKEN_TYPES.TRUE:
                if (parserState === PARSER_STATES.ARRAY) {
                  pointer.key++;
                  lineCounter += 1;
                  setLine(pointersLen + extraPad, pointer.key, undefined);
                } else {
                  pointer.isKey = true;
                }

                ind = pads.length - 1;
                values[ind] = true;
                break;

              case TOKEN_TYPES.FALSE:
                if (parserState === PARSER_STATES.ARRAY) {
                  pointer.key++;
                  lineCounter += 1;
                  setLine(pointersLen + extraPad, pointer.key, undefined);
                } else {
                  pointer.isKey = true;
                }

                ind = pads.length - 1;
                values[ind] = false;

                break;

              case TOKEN_TYPES.NULL:
                if (parserState === PARSER_STATES.ARRAY) {
                  pointer.key++;
                  lineCounter += 1;
                  setLine(pointersLen + extraPad, pointer.key, undefined);
                } else {
                  pointer.isKey = true;
                }

                ind = pads.length - 1;
                values[ind] = null;
                break;

              default:
                console.error(parserState, i, token, tokens);
                throw new TypeError(token);
            }

            ++i;
          }

          performance.measure("parser", "parser");
          // console.log("lines   ", lineCounter - oldCounter)
          oldCounter = lineCounter;

          // set height for virtual scroller
          th = lineCounter * rh + 74; // virtual height
          // th = 10_000_000_000

          if (th < 1e7) {
            // just one page
            h = ph = th;
            n = 1;
            cj = 0;
          } else {
            // break into pages
            h = 1e7;
            ph = h / 100;
            n = Math.ceil(th / ph);
            cj = (th - h) / (n - 1);
          }

          vp = viewer.clientHeight; // viewer height
          canvas.style.height = h;
        }

        await seek();
        renderFreshCanvas();

        let deadline = performance.now() + 50;

        async function doWork() {
          if (!done) {
            await seek();
            if (
              navigator?.scheduling?.isInputPending() ||
              performance.now() >= deadline
            ) {
              await yieldToMain();
              deadline = performance.now() + 50;
            }
            doWork();
          }
        }

        await doWork();
      };

      // A function for shimming scheduler.yield and setTimeout:
      function yieldToMain() {
        // Use scheduler.yield if it exists:
        if ("scheduler" in window && "yield" in scheduler) {
          return scheduler.yield();
        }

        // Fall back to setTimeout:
        return new Promise((resolve) => {
          setTimeout(resolve, 0);
        });
      }

      window.addEventListener("resize", (event) => {
        linesShown = Math.floor(document.body.clientHeight / 28) + 10;

        vp = viewer.clientHeight; // viewer height

        renderFreshCanvas();
      });

      function renderFreshCanvas() {
        var y = viewer.scrollTop + virtualScrollOffset,
          buffer = vp,
          top = Math.floor((y - buffer) / rh),
          bottom = Math.ceil((y + vp + buffer) / rh);

        start = Math.max(0, top);
        bottom = Math.min(th / rh, bottom);

        let diff = bottom - start;

        canvas.innerHTML = "";
        virtualDom = document.createDocumentFragment();
        for (i = 0; i <= diff; ++i) {
          let ind = pads.length - 1;
          if (i + start > ind) continue;

          const pad = pads[i + start];
          const key = keys[i + start];
          const value = values[i + start];

          const el = baseLineElement.cloneNode(true);

          // Padding
          for (var j = 0; j < pad; j++) {
            const col = baseCol.cloneNode();
            el.prepend(col);
          }

          // key
          if (typeof key !== "undefined") {
            let keyEl = el.querySelector(".key");
            keyEl.classList.add(typeof key);
            keyEl.innerText = `${key}:`;
          }

          // value
          let valueType = typeof value;
          if (valueType !== "undefined") {
            let valueEl = el.querySelector(".value");
            valueEl.classList.add(valueType);
            if (value === TOKEN_TYPES.LEFT_BRACKET) {
              valueEl.innerText = "[";
            } else if (value === TOKEN_TYPES.RIGHT_BRACKET) {
              valueEl.innerText = "]";
            } else if (valueType === "string") {
              valueEl.innerText = `"${String(value)}"`;
            } else {
              valueEl.innerText = String(value);
            }
          }

          el.style.top = (start + i) * rh - virtualScrollOffset;
          virtualDom.appendChild(el);
        }
        canvas.appendChild(virtualDom);
      }

      // Large virtual scroller
      var virtualScrollPage = 0; // current page
      var virtualScrollOffset = 0; // current page offset
      var prevScrollTop = 0;

      var content = canvas;

      // viewport.css("height", vp);
      // content.css("height", h);

      viewer.addEventListener("scroll", onScroll);

      function onScroll() {
        var scrollTop = viewer.scrollTop;

        if (Math.abs(scrollTop - prevScrollTop) > vp) {
          onJump();
        } else {
          onNearScroll();
        }

        renderFreshCanvas();
      }

      function onNearScroll() {
        var scrollTop = viewer.scrollTop;

        // next virtualScrollPage
        if (scrollTop + virtualScrollOffset > (virtualScrollPage + 1) * ph) {
          virtualScrollPage++;
          virtualScrollOffset = Math.round(virtualScrollPage * cj);
          viewer.scrollTop = prevScrollTop = scrollTop - cj;
        } else if (scrollTop + virtualScrollOffset < virtualScrollPage * ph) {
          // prev virtualScrollPage
          virtualScrollPage--;
          virtualScrollOffset = Math.round(virtualScrollPage * cj);
          viewer.scrollTop = prevScrollTop = scrollTop + cj;
        } else {
          prevScrollTop = scrollTop;
        }
      }

      function onJump() {
        var scrollTop = viewer.scrollTop;
        virtualScrollPage = Math.floor(
          scrollTop * ((th - vp) / (h - vp)) * (1 / ph),
        );
        virtualScrollOffset = Math.round(virtualScrollPage * cj);
        prevScrollTop = scrollTop;
      }
    </script>
  </body>
</html>
